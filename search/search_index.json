{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"toychain toychain is a very simplistic blockchain node modeling in Python. While the code is my own adaptation, the implementation and architecture is from the very good tutorial by Daniel van Flymen. This adaptation uses FastAPI as a web framework, and uvicorn as ASGI server instead of the Flask app from van Flymen's tutorial. Link to documentation . License Copyright \u00a9 2020 Felix Soubelet. MIT License","title":"Home"},{"location":"#license","text":"Copyright \u00a9 2020 Felix Soubelet. MIT License","title":"License"},{"location":"docs/Getting_Started/","text":"Getting Started Installation There are two possible methods for installing and running toychain: either as a Python package with pip , or as a Docker image. With pip You can now install this simply in a virtual environment with: pip install toychain Installation in a virtual environment Don't know what a virtual environment is or how to set it up? Here is a good primer on virtual environments by RealPython. How about a development environment? Sure thing. This repository uses Poetry as a packaging and build tool. To set yourself up, get a local copy through VCS and run: poetry install You're now good to go, code away! To test your changes to the code, you can start up a node at localhost:5000 with the predefined command: poetry run node With Docker It is possible to run nodes as Docker containers. For now, there is no existing image you can pull from Docker Hub, so you will have to build it localy. To do so, clone the repository and build the image with: docker build -t toychain . Running As a Python Package The usage is simple and goes as: python -m toychain Command Line Options You can specify the port as well as the host on which to run the node with the --port and --host flags, which allows you to easily spin up several nodes. The usage goes as: usage: __main__.py [ -h ] [ -p PORT ] [ --host HOST ] optional arguments: -h, --help show this help message and exit -p PORT, --port PORT The port on which to run a node. Defaults to 5000 . --host HOST The host on which to run the node. Defaults to '127.0.0.1' , known as 'localhost' . As a Docker Container Assuming you have built the image as instructed above, you can then run a container by mapping the node's port to a desired one at localhost on your machine. To map the node to port 5000, run: docker run --init --rm -p 5000 :5000 toychain To emulate additional nodes, vary the public port number: docker run --init --rm -p 5001 :5000 toychain docker run --init --rm -p 5002 :5000 toychain docker run --init --rm -p 5003 :5000 toychain You can then play around by POSTing to /nodes/register to add all your running instances to one another's networks, POSTing transactions, mining new blocks, and resolving the blockchain. Refer to the Functionality section of this documentation for more information. What can I do with this? Honestly, not much. This was a learning project and it only models a blockchain's most simple functionality. But you can toy around with that, or try to build on it.","title":"Getting Started"},{"location":"docs/Getting_Started/#getting-started","text":"","title":"Getting Started"},{"location":"docs/Getting_Started/#installation","text":"There are two possible methods for installing and running toychain: either as a Python package with pip , or as a Docker image.","title":"Installation"},{"location":"docs/Getting_Started/#with-pip","text":"You can now install this simply in a virtual environment with: pip install toychain Installation in a virtual environment Don't know what a virtual environment is or how to set it up? Here is a good primer on virtual environments by RealPython. How about a development environment? Sure thing. This repository uses Poetry as a packaging and build tool. To set yourself up, get a local copy through VCS and run: poetry install You're now good to go, code away! To test your changes to the code, you can start up a node at localhost:5000 with the predefined command: poetry run node","title":"With pip"},{"location":"docs/Getting_Started/#with-docker","text":"It is possible to run nodes as Docker containers. For now, there is no existing image you can pull from Docker Hub, so you will have to build it localy. To do so, clone the repository and build the image with: docker build -t toychain .","title":"With Docker"},{"location":"docs/Getting_Started/#running","text":"","title":"Running"},{"location":"docs/Getting_Started/#as-a-python-package","text":"The usage is simple and goes as: python -m toychain Command Line Options You can specify the port as well as the host on which to run the node with the --port and --host flags, which allows you to easily spin up several nodes. The usage goes as: usage: __main__.py [ -h ] [ -p PORT ] [ --host HOST ] optional arguments: -h, --help show this help message and exit -p PORT, --port PORT The port on which to run a node. Defaults to 5000 . --host HOST The host on which to run the node. Defaults to '127.0.0.1' , known as 'localhost' .","title":"As a Python Package"},{"location":"docs/Getting_Started/#as-a-docker-container","text":"Assuming you have built the image as instructed above, you can then run a container by mapping the node's port to a desired one at localhost on your machine. To map the node to port 5000, run: docker run --init --rm -p 5000 :5000 toychain To emulate additional nodes, vary the public port number: docker run --init --rm -p 5001 :5000 toychain docker run --init --rm -p 5002 :5000 toychain docker run --init --rm -p 5003 :5000 toychain You can then play around by POSTing to /nodes/register to add all your running instances to one another's networks, POSTing transactions, mining new blocks, and resolving the blockchain. Refer to the Functionality section of this documentation for more information. What can I do with this? Honestly, not much. This was a learning project and it only models a blockchain's most simple functionality. But you can toy around with that, or try to build on it.","title":"As a Docker Container"},{"location":"docs/Walkthrough/","text":"In this section, we'll walk through the process of spinning up a few nodes and playing around with their functionality by adding and querying their chains. I will be using FastAPI's automatic interactive documentation to perform those operations (see the Magic documentation block below), but you can also use your favorite the REST client or simply the command line. If you decide to go with the latter, you will find included the command to run for each operation. Starting Nodes For convenience, I'll use Docker to spin up two detached nodes: docker run --init --rm -dp 5000 :5000 toychain docker run --init --rm -dp 5001 :5000 toychain As a Python command If you don't want to use Docker, you can use the toychain Python package. Run: python -m toychain --port 5000 python -m toychain --port 5001 About processes The node needs an ASGI server to run, and we're using uvicorn for this. However, since uvicorn.run() is a blocking call you'll need to run the above commands in two separated terminal windows or tabs. We now have two nodes running at respectively localhost:5000 and localhost:5001 , and each one has initialized its blockchain at startup. Magic documentation If you open your browser and head over to the /docs (or /redocs ) endpoint for any one of those two, you should see the automatic documentation generated by FastAPI . Each item expands to reveal details, and even let you interact with the corresponding endpoint if you click the Try it out option. Registering Nodes Let's register each node in the other's network so they'll be aware of each other's existence. To do so, we have to POST to a node's /nodes/register endpoint, with the list of node addresses to register. Let's first register the node at localhost:5001 to the node at localhost:5000 : cURL curl --request POST \\ --url http://localhost:5000/nodes/register \\ --header 'content-type: application/json' \\ --data '{ \"nodes\": [\"http://127.0.0.1:5001\"] }' HTTPie echo '{ \"nodes\": [\"http://127.0.0.1:5001\"] }' | http POST http://localhost:5000/nodes/register Wget wget -qSO- \\ --header = 'Content-Type: application/json' \\ --post-data = '{ \"nodes\": [\"http://127.0.0.1:5001\"] }' http://localhost:5000/nodes/register Through documentation To do so through the documentation, let's expand the nodes/register endpoint section at localhost:5000/docs and click on Try it out . There, in the request body, let's replace string by http://127.0.0.1:5001 and click Execute . You should receive a response saying: { \"message\" : \"1 new nodes have been successfully added\" , \"total_nodes\" : [ \"127.0.0.1:5001\" ] } Registering the second one is the same process, by POSTing to localhost:5001/nodes/register and changing the port number to 5000 in the request body. Watch the logs If you're running as a Python command or without detaching the Docker container, you should see the logging outputs. They'll give you some insight into what goes on when we trigger those operations. Adding Transactions Alright, we have two nodes up and running, aware of each other. What if someone named Lea makes a transaction and sends 10 coins to Mark. Let's make the nodes aware. For this, we need to create the appropriate payload and POST it to the transactions/new endpoint of our running nodes: cURL curl --request POST \\ --url http://localhost:5000/transactions/new \\ --header 'content-type: application/json' \\ --data '{ \"sender\": \"Lea\", \"recipient\": \"Mark\", \"amount\": 10 }' HTTPie echo '{ \"sender\": \"Lea\", \"recipient\": \"Mark\", \"amount\": 10 }' | http POST http://localhost:5000/transactions/new Wget wget -qSO- \\ --header = 'Content-Type: application/json' \\ --post-data = '{ \"sender\": \"Lea\", \"recipient\": \"Mark\", \"amount\": 10 }' http://localhost:5000/transactions/new Through documentation Expand the transactions/new endpoint section at localhost:5000/docs , click Try it out and fill in the request body as in the screenshot below. Note Technically the sender and recipient fields should be cryptowallet addresses, but we'll keep names for convenience's sake. We get a successful response reading: { \"message\" : \"Transaction added to the list of current transactions and will be mined into the block at index 2\" } Let's POST the same transaction at localhost:5001/transactions/new so both nodes receive the same info. Oh no! Lea just realized she actually owed Mark 15 coins and not 10. She sends a new transaction: let's go ahead and repeat the above process with an amount of 5. Mining Blocks The transactions registered, it's time write to them in the chain by mining a block. To do so, we need to trigger a block mining by sending a GET request at the /mine endpoint: cURL curl --request GET \\ --url http://localhost:5000/mine \\ --header 'content-type: application/json' HTTPie http http://localhost:5000/mine Wget wget -qSO- --header = 'Content-Type: application/json' http://localhost:5000/mine Through documentation Expand the /mine endpoint section at localhost:5000/docs , click Try it out then Execute . This takes a few seconds, since mining requires computing a proof of work for the block. The confirmation follows: { \"index\" : 2 , \"message\" : \"New Block Forged\" , \"previous_hash\" : \"022ec08cc0852b351781413c74a4f189e7910de1029d0ba33b04b178d9fe2b86\" , \"proof\" : 35293 , \"transactions\" : [ { \"amount\" : 10.0 , \"recipient\" : \"Mark\" , \"sender\" : \"Lea\" }, { \"amount\" : 5.0 , \"recipient\" : \"Mark\" , \"sender\" : \"Lea\" }, { \"amount\" : 1 , \"recipient\" : \"65d83305a11e458abb96bdfb2256b365\" , \"sender\" : \"0\" } ] } It contains many things: the index at which the block is located in the chain, a confirmation message , the hash of the previous block in the chain ( previous_hash ), the proof of work for this block, the list of transactions written in this block. Where does this third transaction come from? For cryptocurrencies, many entities listen for transactions in order to mine them into new blocks. Whoever manages to get the proof of work first will be the block's creator, and can add a special transaction in which they get rewared some coins: it's the block reward . Since through this process creating blocks introduces new bits of currency into the economy, it is called mining . The sender is set to 0 to specify that the transaction corresponds to currency creation, and the recipient is set to this node's UUID. Let's also send a GET request at localhost:5001/mine so both nodes mine a block. Querying Chains To see where a node's chain is at, we can send a GET request to the /chain endpoint to receive the full chain: cURL curl --request GET \\ --url http://localhost:5000/chain \\ --header 'content-type: application/json' HTTPie http http://localhost:5000/chain Wget wget -qSO- --header = 'Content-Type: application/json' http://localhost:5000/chain Through documentation Expand the /chain endpoint section at localhost:5000/docs , click Try it out then Execute . Here is the response payload, containing the full chain (all blocks) and its length : { \"chain\" : [ { \"index\" : 1 , \"previous_hash\" : 1 , \"proof\" : 100 , \"timestamp\" : 1591985797.9658592 , \"transactions\" : [] }, { \"index\" : 2 , \"previous_hash\" : \"022ec08cc0852b351781413c74a4f189e7910de1029d0ba33b04b178d9fe2b86\" , \"proof\" : 35293 , \"timestamp\" : 1591985867.153815 , \"transactions\" : [ { \"amount\" : 10.0 , \"recipient\" : \"Mark\" , \"sender\" : \"Lea\" }, { \"amount\" : 5.0 , \"recipient\" : \"Mark\" , \"sender\" : \"Lea\" }, { \"amount\" : 1 , \"recipient\" : \"65d83305a11e458abb96bdfb2256b365\" , \"sender\" : \"0\" } ] } ], \"length\" : 2 } Where does the first block come from? A first block is always mined when the node is started. This is because in this implementation, the proof of work is based on the proof value of the previous block, so manually mining a block requires that there is already a previous one. The dummy first block is always initiated with a previous_hash of 1, a proof of 100 and no transactions. Resolving Conflicts Right now, both nodes have the same chain (with slightly different timestamps for the blocks). What happens when a node gets slightly off tune with the rest of the others, or hears conflicting information from the nodes in the network? This is when the consensus algorithm is used: we decide to refer to the longest chain, the one with the most work put into it. Let's say that we mine a new block, but only on our node at localhost:5001 : cURL curl --request GET \\ --url http://localhost:5001/mine \\ --header 'content-type: application/json' HTTPie http http://localhost:5001/mine Wget wget -qSO- --header = 'Content-Type: application/json' http://localhost:5001/mine Through documentation Expand the /mine endpoint section at localhost:5001/docs , click Try it out then Execute . Our node at localhost:5000 is now one block behind and needs to catch up. Let's have it run the consensus algorithm by sending a GET request at its /nodes/resolve endpoint, and see if it adopts the other chain (which is now the longest one): cURL curl --request GET \\ --url http://localhost:5000/nodes/resolve \\ --header 'content-type: application/json' HTTPie http http://localhost:5000/nodes/resolve Wget wget -qSO- --header = 'Content-Type: application/json' http://localhost:5000/nodes/resolve Through documentation Expand the /nodes/resolve endpoint section at localhost:5000/docs , click Try it out then Execute . Here is the response: { \"message\" : \"Our chain was replaced\" , \"new_chain\" : [ { \"index\" : 1 , \"previous_hash\" : 1 , \"proof\" : 100 , \"timestamp\" : 1591985802.621658 , \"transactions\" : [] }, { \"index\" : 2 , \"previous_hash\" : \"be86c08da07a6f5863b3bcacaf1e945d53b407604c6b4b01e02daa5342f6630a\" , \"proof\" : 35293 , \"timestamp\" : 1591985874.232369 , \"transactions\" : [ { \"amount\" : 10.0 , \"recipient\" : \"Mark\" , \"sender\" : \"Lea\" }, { \"amount\" : 5.0 , \"recipient\" : \"Mark\" , \"sender\" : \"Lea\" }, { \"amount\" : 1 , \"recipient\" : \"2e2cdb00cc614637b248f7ae1806cd8b\" , \"sender\" : \"0\" } ] }, { \"index\" : 3 , \"previous_hash\" : \"9dad19a1b27ecee43df60fe2d073d402b484a47a89e1430e847a35520cf3038a\" , \"proof\" : 35089 , \"timestamp\" : 1591986065.7304928 , \"transactions\" : [ { \"amount\" : 1 , \"recipient\" : \"2e2cdb00cc614637b248f7ae1806cd8b\" , \"sender\" : \"0\" } ] } ] } As we can see in the returned message , the node did replace its chain. You can GET localhost:5001 to make sure the chain returned in the message above corresponds to the chain from the second node at localhost:5001 . Why do we keep the longest chain? In short, for safety and reliability reasons. Once again, I can only recommend watching this excellent video by 3Blue1Brown. To only watch the explanation of why we keep the longest chain, you can skip to this timestamp , but watching the whole thing will give you a better understanding.","title":"Example Walkthrough"},{"location":"docs/Walkthrough/#starting-nodes","text":"For convenience, I'll use Docker to spin up two detached nodes: docker run --init --rm -dp 5000 :5000 toychain docker run --init --rm -dp 5001 :5000 toychain As a Python command If you don't want to use Docker, you can use the toychain Python package. Run: python -m toychain --port 5000 python -m toychain --port 5001 About processes The node needs an ASGI server to run, and we're using uvicorn for this. However, since uvicorn.run() is a blocking call you'll need to run the above commands in two separated terminal windows or tabs. We now have two nodes running at respectively localhost:5000 and localhost:5001 , and each one has initialized its blockchain at startup. Magic documentation If you open your browser and head over to the /docs (or /redocs ) endpoint for any one of those two, you should see the automatic documentation generated by FastAPI . Each item expands to reveal details, and even let you interact with the corresponding endpoint if you click the Try it out option.","title":"Starting Nodes"},{"location":"docs/Walkthrough/#registering-nodes","text":"Let's register each node in the other's network so they'll be aware of each other's existence. To do so, we have to POST to a node's /nodes/register endpoint, with the list of node addresses to register. Let's first register the node at localhost:5001 to the node at localhost:5000 : cURL curl --request POST \\ --url http://localhost:5000/nodes/register \\ --header 'content-type: application/json' \\ --data '{ \"nodes\": [\"http://127.0.0.1:5001\"] }' HTTPie echo '{ \"nodes\": [\"http://127.0.0.1:5001\"] }' | http POST http://localhost:5000/nodes/register Wget wget -qSO- \\ --header = 'Content-Type: application/json' \\ --post-data = '{ \"nodes\": [\"http://127.0.0.1:5001\"] }' http://localhost:5000/nodes/register Through documentation To do so through the documentation, let's expand the nodes/register endpoint section at localhost:5000/docs and click on Try it out . There, in the request body, let's replace string by http://127.0.0.1:5001 and click Execute . You should receive a response saying: { \"message\" : \"1 new nodes have been successfully added\" , \"total_nodes\" : [ \"127.0.0.1:5001\" ] } Registering the second one is the same process, by POSTing to localhost:5001/nodes/register and changing the port number to 5000 in the request body. Watch the logs If you're running as a Python command or without detaching the Docker container, you should see the logging outputs. They'll give you some insight into what goes on when we trigger those operations.","title":"Registering Nodes"},{"location":"docs/Walkthrough/#adding-transactions","text":"Alright, we have two nodes up and running, aware of each other. What if someone named Lea makes a transaction and sends 10 coins to Mark. Let's make the nodes aware. For this, we need to create the appropriate payload and POST it to the transactions/new endpoint of our running nodes: cURL curl --request POST \\ --url http://localhost:5000/transactions/new \\ --header 'content-type: application/json' \\ --data '{ \"sender\": \"Lea\", \"recipient\": \"Mark\", \"amount\": 10 }' HTTPie echo '{ \"sender\": \"Lea\", \"recipient\": \"Mark\", \"amount\": 10 }' | http POST http://localhost:5000/transactions/new Wget wget -qSO- \\ --header = 'Content-Type: application/json' \\ --post-data = '{ \"sender\": \"Lea\", \"recipient\": \"Mark\", \"amount\": 10 }' http://localhost:5000/transactions/new Through documentation Expand the transactions/new endpoint section at localhost:5000/docs , click Try it out and fill in the request body as in the screenshot below. Note Technically the sender and recipient fields should be cryptowallet addresses, but we'll keep names for convenience's sake. We get a successful response reading: { \"message\" : \"Transaction added to the list of current transactions and will be mined into the block at index 2\" } Let's POST the same transaction at localhost:5001/transactions/new so both nodes receive the same info. Oh no! Lea just realized she actually owed Mark 15 coins and not 10. She sends a new transaction: let's go ahead and repeat the above process with an amount of 5.","title":"Adding Transactions"},{"location":"docs/Walkthrough/#mining-blocks","text":"The transactions registered, it's time write to them in the chain by mining a block. To do so, we need to trigger a block mining by sending a GET request at the /mine endpoint: cURL curl --request GET \\ --url http://localhost:5000/mine \\ --header 'content-type: application/json' HTTPie http http://localhost:5000/mine Wget wget -qSO- --header = 'Content-Type: application/json' http://localhost:5000/mine Through documentation Expand the /mine endpoint section at localhost:5000/docs , click Try it out then Execute . This takes a few seconds, since mining requires computing a proof of work for the block. The confirmation follows: { \"index\" : 2 , \"message\" : \"New Block Forged\" , \"previous_hash\" : \"022ec08cc0852b351781413c74a4f189e7910de1029d0ba33b04b178d9fe2b86\" , \"proof\" : 35293 , \"transactions\" : [ { \"amount\" : 10.0 , \"recipient\" : \"Mark\" , \"sender\" : \"Lea\" }, { \"amount\" : 5.0 , \"recipient\" : \"Mark\" , \"sender\" : \"Lea\" }, { \"amount\" : 1 , \"recipient\" : \"65d83305a11e458abb96bdfb2256b365\" , \"sender\" : \"0\" } ] } It contains many things: the index at which the block is located in the chain, a confirmation message , the hash of the previous block in the chain ( previous_hash ), the proof of work for this block, the list of transactions written in this block. Where does this third transaction come from? For cryptocurrencies, many entities listen for transactions in order to mine them into new blocks. Whoever manages to get the proof of work first will be the block's creator, and can add a special transaction in which they get rewared some coins: it's the block reward . Since through this process creating blocks introduces new bits of currency into the economy, it is called mining . The sender is set to 0 to specify that the transaction corresponds to currency creation, and the recipient is set to this node's UUID. Let's also send a GET request at localhost:5001/mine so both nodes mine a block.","title":"Mining Blocks"},{"location":"docs/Walkthrough/#querying-chains","text":"To see where a node's chain is at, we can send a GET request to the /chain endpoint to receive the full chain: cURL curl --request GET \\ --url http://localhost:5000/chain \\ --header 'content-type: application/json' HTTPie http http://localhost:5000/chain Wget wget -qSO- --header = 'Content-Type: application/json' http://localhost:5000/chain Through documentation Expand the /chain endpoint section at localhost:5000/docs , click Try it out then Execute . Here is the response payload, containing the full chain (all blocks) and its length : { \"chain\" : [ { \"index\" : 1 , \"previous_hash\" : 1 , \"proof\" : 100 , \"timestamp\" : 1591985797.9658592 , \"transactions\" : [] }, { \"index\" : 2 , \"previous_hash\" : \"022ec08cc0852b351781413c74a4f189e7910de1029d0ba33b04b178d9fe2b86\" , \"proof\" : 35293 , \"timestamp\" : 1591985867.153815 , \"transactions\" : [ { \"amount\" : 10.0 , \"recipient\" : \"Mark\" , \"sender\" : \"Lea\" }, { \"amount\" : 5.0 , \"recipient\" : \"Mark\" , \"sender\" : \"Lea\" }, { \"amount\" : 1 , \"recipient\" : \"65d83305a11e458abb96bdfb2256b365\" , \"sender\" : \"0\" } ] } ], \"length\" : 2 } Where does the first block come from? A first block is always mined when the node is started. This is because in this implementation, the proof of work is based on the proof value of the previous block, so manually mining a block requires that there is already a previous one. The dummy first block is always initiated with a previous_hash of 1, a proof of 100 and no transactions.","title":"Querying Chains"},{"location":"docs/Walkthrough/#resolving-conflicts","text":"Right now, both nodes have the same chain (with slightly different timestamps for the blocks). What happens when a node gets slightly off tune with the rest of the others, or hears conflicting information from the nodes in the network? This is when the consensus algorithm is used: we decide to refer to the longest chain, the one with the most work put into it. Let's say that we mine a new block, but only on our node at localhost:5001 : cURL curl --request GET \\ --url http://localhost:5001/mine \\ --header 'content-type: application/json' HTTPie http http://localhost:5001/mine Wget wget -qSO- --header = 'Content-Type: application/json' http://localhost:5001/mine Through documentation Expand the /mine endpoint section at localhost:5001/docs , click Try it out then Execute . Our node at localhost:5000 is now one block behind and needs to catch up. Let's have it run the consensus algorithm by sending a GET request at its /nodes/resolve endpoint, and see if it adopts the other chain (which is now the longest one): cURL curl --request GET \\ --url http://localhost:5000/nodes/resolve \\ --header 'content-type: application/json' HTTPie http http://localhost:5000/nodes/resolve Wget wget -qSO- --header = 'Content-Type: application/json' http://localhost:5000/nodes/resolve Through documentation Expand the /nodes/resolve endpoint section at localhost:5000/docs , click Try it out then Execute . Here is the response: { \"message\" : \"Our chain was replaced\" , \"new_chain\" : [ { \"index\" : 1 , \"previous_hash\" : 1 , \"proof\" : 100 , \"timestamp\" : 1591985802.621658 , \"transactions\" : [] }, { \"index\" : 2 , \"previous_hash\" : \"be86c08da07a6f5863b3bcacaf1e945d53b407604c6b4b01e02daa5342f6630a\" , \"proof\" : 35293 , \"timestamp\" : 1591985874.232369 , \"transactions\" : [ { \"amount\" : 10.0 , \"recipient\" : \"Mark\" , \"sender\" : \"Lea\" }, { \"amount\" : 5.0 , \"recipient\" : \"Mark\" , \"sender\" : \"Lea\" }, { \"amount\" : 1 , \"recipient\" : \"2e2cdb00cc614637b248f7ae1806cd8b\" , \"sender\" : \"0\" } ] }, { \"index\" : 3 , \"previous_hash\" : \"9dad19a1b27ecee43df60fe2d073d402b484a47a89e1430e847a35520cf3038a\" , \"proof\" : 35089 , \"timestamp\" : 1591986065.7304928 , \"transactions\" : [ { \"amount\" : 1 , \"recipient\" : \"2e2cdb00cc614637b248f7ae1806cd8b\" , \"sender\" : \"0\" } ] } ] } As we can see in the returned message , the node did replace its chain. You can GET localhost:5001 to make sure the chain returned in the message above corresponds to the chain from the second node at localhost:5001 . Why do we keep the longest chain? In short, for safety and reliability reasons. Once again, I can only recommend watching this excellent video by 3Blue1Brown. To only watch the explanation of why we keep the longest chain, you can skip to this timestamp , but watching the whole thing will give you a better understanding.","title":"Resolving Conflicts"},{"location":"docs/Functionality/Blockchain/","text":"The Blockchain Implementation The blockchain functionality is provided by a single class, BlockChain , in the toychain.blockchain module. It is a simple list of blocks, each block in the chain consisting of a dictionnary with the following keys: the index at which it is located in the chain, a timestamp of when the block was added to the chain, the list of transactions recorded in the block, the proof of validity for itself, a previous_hash tag referencing the hash of the previous block in the chain, for immutability. What's in the Blockchain? The json payload for an example block with a single transaction would look like this: block = { \"index\" : 1 , \"timestamp\" : 1506057125.900785 , \"transactions\" : [ { \"sender\" : \"8527147fe1f5426f9dd545de4b27ee00\" , \"recipient\" : \"a77f5cdfa2934df3954a5c7c7da5df1f\" , \"amount\" : 5 , } ], \"proof\" : 324984774000 , \"previous_hash\" : \"2cf24dba5fb0a30e26e83b2ac5b9e29e1b161e5c1fa7425e73043362938b9824\" } A block contains: the index at which it is located in the chain, the timestamp of the block's creation, the list of transactions written in this block, the proof of work for this block, calculated from the previous block's proof of work, the hash of the previous block in the chain ( previous_hash ). Want to learn a bit about Blockchains? If you want to dive a bit into how cryptocurrencies and blockchains work, I recommend you watch this excellent video by 3Blue1Brown.","title":"Blockchain"},{"location":"docs/Functionality/Blockchain/#the-blockchain-implementation","text":"The blockchain functionality is provided by a single class, BlockChain , in the toychain.blockchain module. It is a simple list of blocks, each block in the chain consisting of a dictionnary with the following keys: the index at which it is located in the chain, a timestamp of when the block was added to the chain, the list of transactions recorded in the block, the proof of validity for itself, a previous_hash tag referencing the hash of the previous block in the chain, for immutability.","title":"The Blockchain Implementation"},{"location":"docs/Functionality/Blockchain/#whats-in-the-blockchain","text":"The json payload for an example block with a single transaction would look like this: block = { \"index\" : 1 , \"timestamp\" : 1506057125.900785 , \"transactions\" : [ { \"sender\" : \"8527147fe1f5426f9dd545de4b27ee00\" , \"recipient\" : \"a77f5cdfa2934df3954a5c7c7da5df1f\" , \"amount\" : 5 , } ], \"proof\" : 324984774000 , \"previous_hash\" : \"2cf24dba5fb0a30e26e83b2ac5b9e29e1b161e5c1fa7425e73043362938b9824\" } A block contains: the index at which it is located in the chain, the timestamp of the block's creation, the list of transactions written in this block, the proof of work for this block, calculated from the previous block's proof of work, the hash of the previous block in the chain ( previous_hash ). Want to learn a bit about Blockchains? If you want to dive a bit into how cryptocurrencies and blockchains work, I recommend you watch this excellent video by 3Blue1Brown.","title":"What's in the Blockchain?"},{"location":"docs/Functionality/Node/","text":"The Node Implementation A node is ran as a REST API using the FastAPI web framework, and is attributed a UUID at startup. Each node stores a full blockchain, the current transactions (to be written in the next block), and the list of other nodes registered in the network. Each node's blockchain is a BlockChain object from the toychain.blockchain module. A node can: Add a transaction to the list of current transactions, Add a new block to its chain, Run the proof of work algorithm, Validate the proof of a block, Register other nodes on the network, Infer an arbitrary node's blockchain's validity, Resolve conflict through a consensus algorithm, checking all nodes' chains in the network and adopting the longest valid one. What endpoints are available for those actions? GET endpoint /mine to trigger the addition of a new block to the chain, POST endpoint /transactions/new to add a transaction to the node's list, GET endpoint /chain to pull the full chain, POST endpoint /nodes/register to register other nodes' addresses as part of the network, GET endpoint /nodes/resolve : to trigger a run of the consensus algorithm and resolve conflicts: the longest valid chain of all nodes in the network is used as reference, replacing the local one, and is returned. How do I remember these? Once the server is running, FastAPI serves an automated documentation at the /docs and /redoc endpoints. So if your node is running at localhost:5000 , head over to localhost:5000/docs for instance. If you simply head to localhost:5000 , you'll get a hint on where to go ;) Interacting with a Node Let's consider our node is running at localhost:5000 . Here's how to POST a transaction to the node's transactions/new endpoint with either cURL , HTTPie or Wget : cURL curl --request POST \\ --url http://localhost:5000/transactions/new \\ --header 'content-type: application/json' \\ --data '{ \"sender\": \"d4ee26eee15148ee92c6cd394edd974e\", \"recipient\": \"someone-other-address\", \"amount\": 5 }' HTTPie echo '{ \"sender\": \"d4ee26eee15148ee92c6cd394edd974e\", \"recipient\": \"someone-other-address\", \"amount\": 5 }' | http POST http://localhost:5000/transactions/new Wget wget -qSO- \\ --header = 'Content-Type: application/json' \\ --post-data = '{ \"sender\": \"d4ee26eee15148ee92c6cd394edd974e\", \"recipient\": \"someone-other-address\", \"amount\": 5 }' http://localhost:5000/transactions/new Let's now consider that we have started a second node at localhost:5001 . POSTing a payload to register this new node to the first one's network would be done as follows: cURL curl --request POST \\ --url http://localhost:5000/nodes/register \\ --header 'content-type: application/json' \\ --data '{ \"nodes\": [\"http://127.0.0.1:5001\"] }' HTTPie echo '{ \"nodes\": [\"http://127.0.0.1:5001\"] }' | http POST http://localhost:5000/nodes/register Wget wget -qSO- \\ --header = 'Content-Type: application/json' \\ --post-data = '{ \"nodes\": [\"http://127.0.0.1:5001\"] }' http://localhost:5000/nodes/register","title":"Node"},{"location":"docs/Functionality/Node/#the-node-implementation","text":"A node is ran as a REST API using the FastAPI web framework, and is attributed a UUID at startup. Each node stores a full blockchain, the current transactions (to be written in the next block), and the list of other nodes registered in the network. Each node's blockchain is a BlockChain object from the toychain.blockchain module. A node can: Add a transaction to the list of current transactions, Add a new block to its chain, Run the proof of work algorithm, Validate the proof of a block, Register other nodes on the network, Infer an arbitrary node's blockchain's validity, Resolve conflict through a consensus algorithm, checking all nodes' chains in the network and adopting the longest valid one. What endpoints are available for those actions? GET endpoint /mine to trigger the addition of a new block to the chain, POST endpoint /transactions/new to add a transaction to the node's list, GET endpoint /chain to pull the full chain, POST endpoint /nodes/register to register other nodes' addresses as part of the network, GET endpoint /nodes/resolve : to trigger a run of the consensus algorithm and resolve conflicts: the longest valid chain of all nodes in the network is used as reference, replacing the local one, and is returned. How do I remember these? Once the server is running, FastAPI serves an automated documentation at the /docs and /redoc endpoints. So if your node is running at localhost:5000 , head over to localhost:5000/docs for instance. If you simply head to localhost:5000 , you'll get a hint on where to go ;)","title":"The Node Implementation"},{"location":"docs/Functionality/Node/#interacting-with-a-node","text":"Let's consider our node is running at localhost:5000 . Here's how to POST a transaction to the node's transactions/new endpoint with either cURL , HTTPie or Wget : cURL curl --request POST \\ --url http://localhost:5000/transactions/new \\ --header 'content-type: application/json' \\ --data '{ \"sender\": \"d4ee26eee15148ee92c6cd394edd974e\", \"recipient\": \"someone-other-address\", \"amount\": 5 }' HTTPie echo '{ \"sender\": \"d4ee26eee15148ee92c6cd394edd974e\", \"recipient\": \"someone-other-address\", \"amount\": 5 }' | http POST http://localhost:5000/transactions/new Wget wget -qSO- \\ --header = 'Content-Type: application/json' \\ --post-data = '{ \"sender\": \"d4ee26eee15148ee92c6cd394edd974e\", \"recipient\": \"someone-other-address\", \"amount\": 5 }' http://localhost:5000/transactions/new Let's now consider that we have started a second node at localhost:5001 . POSTing a payload to register this new node to the first one's network would be done as follows: cURL curl --request POST \\ --url http://localhost:5000/nodes/register \\ --header 'content-type: application/json' \\ --data '{ \"nodes\": [\"http://127.0.0.1:5001\"] }' HTTPie echo '{ \"nodes\": [\"http://127.0.0.1:5001\"] }' | http POST http://localhost:5000/nodes/register Wget wget -qSO- \\ --header = 'Content-Type: application/json' \\ --post-data = '{ \"nodes\": [\"http://127.0.0.1:5001\"] }' http://localhost:5000/nodes/register","title":"Interacting with a Node"},{"location":"reference/toychain/","text":"Module toychain Sub-modules toychain.blockchain toychain.node","title":"Index"},{"location":"reference/toychain/#module-toychain","text":"","title":"Module toychain"},{"location":"reference/toychain/#sub-modules","text":"toychain.blockchain toychain.node","title":"Sub-modules"},{"location":"reference/toychain/blockchain/","text":"Module toychain.blockchain Simple emulation of a blockchain. View Source \"\"\" Simple emulation of a blockchain. \"\"\" import hashlib from time import time from typing import List , Optional , Set , Union from urllib . parse import ParseResult , ParseResultBytes , urlparse import requests from loguru import logger from pydantic import BaseModel class Transaction ( BaseModel ) : sender : str recipient : str amount : float class Block ( BaseModel ) : index : int timestamp : float transactions : List [ Transaction ] proof : Optional [ int ] previous_hash: str class BlockChain : \"\"\"Simple class to emulate a blockchain\"\"\" __ slots__ = { \"chain\" : \"List of different Block objects making up the blockchain\" , \"current_transactions\" : \"List of Transaction objects to be added to the next block\" , \"nodes\" : \"Set of different nodes registered on the network\" , } def __ init__ ( self ) : self . chain : List [ Block ] = [] self . current_transactions: List [ Transaction ] = [] self . nodes : Set [ str ] = set () logger . debug ( \"Initiating first block\" ) self . add_block ( previous_hash = 1 , proof = 100 ) def add_block ( self , previous_hash: Optional [ str ] = None , proof : int = None ) -> Block : \"\"\" Create a new block and add it to the chain. Args: previous_hash (Optional[str]): hash of the previous block in the chain. proof (int): the proof given by the proof of work algorithm. Returns: The new block. \"\"\" logger . debug ( \"Creating a new block\" ) block = Block ( index = len ( self . chain ) + 1 , timestamp = time (), transactions = self . current_transactions , proof = proof , previous_hash = previous_hash or self . hash ( self . chain [ - 1 ]), ) logger . debug ( \"Resetting the current list of transations\" ) self . current_transactions = [] logger . debug ( \"Adding block to the chain\" ) self . chain . append ( block ) logger . success ( \"Added block to the chain\" ) return block def add_transaction ( self , sender : str = None , recipient : str = None , amount : float = None ) -> int : \"\"\" Adds a new transaction to the list of transactions. Args: sender (str): address of the sender. recipient (str): address of the recipient. amount (float): the amount of the transaction. Returns: An integer containing the index of the block that will hold this transaction. \"\"\" logger . debug ( \"Adding transaction to the list of current transactions\" ) self . current_transactions . append ( Transaction ( sender = sender , recipient = recipient , amount = amount ) ) return self . last_block . index # index is already incremented in block creation @property def last_block ( self ) -> Block : \"\"\" Returns the last block in the chain. Returns: The last block in the chain. \"\"\" return self . chain [ - 1 ] @staticmethod def hash ( block : Block ) -> str : \"\"\" Hashes a new block. Args: block (Block): the block's contents. Returns: The block's hash. \"\"\" # Ordering the block dict for consistent hashes logger . debug ( \"Ordering block dictionary and dumping to json\" ) block_bytes: bytes = block . schema_json (). encode () logger . debug ( \"Hashing dumped block\" ) return hashlib . sha256 ( block_bytes ). hexdigest () @staticmethod def validate_proof ( last_proof: int = None , new_proof: int = None ) -> bool : \"\"\" Validates a proof: does hash(last_proof, new_proof) contain 4 leading zeroes? Args: last_proof (int): the previous proof in the chain. new_proof (int): the new proof. Returns: True if new_proof is validated, False otherwise. \"\"\" logger . trace ( \"Checking proof validity\" ) guess : bytes = f \"{last_proof}{new_proof}\" . encode () guess_hash: str = hashlib . sha256 ( guess ). hexdigest () if guess_hash [ : 4 ] == \"0000\" : logger . debug ( \"Proof iteration is valid\" ) return True logger . trace ( \"Proof is invalid\" ) return False def proof_of_work ( self , last_proof: int = None ) -> int : \"\"\" Simple Proof of Work Algorithm: - Find a number p' such that hash(pp') has leading 4 zeroes, where p is the previous p' - p is the previous proof, and p' is the new proof Args: last_proof (int): the previous proof in the chain. Returns: The new proof, an integer. \"\"\" proof : int = 0 while self . validate_proof ( last_proof = last_proof , new_proof = proof ) is False : logger . trace ( \"Proof didn't pass, iterating\" ) proof += 1 logger . debug ( \"Successfully mined block proof\" ) return proof def register_node ( self , address : str = None ) -> None : \"\"\" Register a new node as part of the network by adding it to the list of nodes. Args: address (str): string, address of node to register. Eg. 'http://192.168.0.5:5000' Returns: Nothing, adds in place. \"\"\" logger . debug ( f \"Parsing new node address '{address}'\" ) parsed_url: Union [ ParseResult , ParseResultBytes ] = urlparse ( address ) node_netloc: str = str ( parsed_url . netloc ) logger . debug ( f \"Netloc for new node is {node_netloc}\" ) logger . debug ( f \"{self.nodes}\" ) if node_netloc in self . nodes : logger . warning ( f \"Node at {address} is already registered, skipping\" ) else : logger . debug ( f \"Adding new element with address {address} to network's registered nodes\" ) self . nodes . add ( node_netloc ) def validate_chain ( self , chain : List [ Block ]) -> bool : \"\"\" Determine if a given blockchain from any arbitrary node in the network is valid. Args: chain (List[Block]): a complete blockchain (list of blocks as dicts). Returns: True if the chain is valid, False otherwise \"\"\" logger . trace ( \"Determining chain validity, starting with first non-dummy block\" ) for previous_block , inspected_block in zip ( chain [:- 1 ], chain [ 1 : ]) : logger . trace ( \"Checking block's hash\" ) if inspected_block . previous_hash ! = self . hash ( previous_block ) : logger . error ( f \"Invalid block tag 'previous_hash': {inspected_block.previous_hash}\" ) return False logger . trace ( \"Checking block's proof of work\" ) if not self . validate_proof ( last_proof = previous_block . proof , new_proof = inspected_block . proof ) : logger . error ( f \"Discrepancy between last block's proof '{previous_block.proof}' and \" f \"inspected block's proof '{inspected_block.proof}'\" ) return False logger . trace ( \"Moving on to next block\" ) logger . debug ( \"Chain is valid\" ) return True def resolve_conflicts ( self ) -> bool : \"\"\" This is the Consensus Algorithm. It resolves conflicts by replacing the node's chain with the longest valid one in the network. Returns: True if the node's chain was replaced, False otherwise \"\"\" neighbouring_nodes = self . nodes new_chain: List [ Block ] = None max_length: int = len ( self . chain ) # initialize with this node's length logger.debug(\"Verifying chains from all nodes in the network\") for node in neighbouring_nodes: logger.debug(f\"Querying node ' { node } ' for its full chain\") node_chain_response = requests.get(f\"http://{node}/chain\") if node_chain_response.status_code == 200: logger.trace(\"Full chain received\") length = node_chain_response.json()[\"length\"] chain = node_chain_response.json()[\"chain\"] logger.trace(\"Checking if requested chain is valid and longer than mine\") if length > max_length and self.validate_chain(chain): max_length = length new_chain = chain if new_chain: logger.info(\"Found a valid chain longer than this node's , adopting it now \") self.chain = new_chain return True logger.info(\" No valid chain was longer than this node ' s \" ) return False Classes Block class Block ( __pydantic_self__ , ** data : Any ) View Source class Block ( BaseModel ) : index : int timestamp : float transactions : List [ Transaction ] proof : Optional [ int ] previous_hash : str Ancestors (in MRO) pydantic.main.BaseModel pydantic.utils.Representation Class variables Config Static methods construct def construct ( _fields_set : Optional [ ForwardRef ( 'SetStr' )] = None , ** values : Any ) -> 'Model' Creates a new model setting dict and fields_set from trusted or pre-validated data. Default values are respected, but no other validation is performed. from_orm def from_orm ( obj : Any ) -> 'Model' parse_file def parse_file ( path : Union [ str , pathlib . Path ], * , content_type : 'unicode' = None , encoding : 'unicode' = 'utf8' , proto : pydantic . parse . Protocol = None , allow_pickle : bool = False ) -> 'Model' parse_obj def parse_obj ( obj : Any ) -> 'Model' parse_raw def parse_raw ( b : Union [ str , bytes ], * , content_type : 'unicode' = None , encoding : 'unicode' = 'utf8' , proto : pydantic . parse . Protocol = None , allow_pickle : bool = False ) -> 'Model' schema def schema ( by_alias : bool = True , ref_template : 'unicode' = '#/definitions/ {model} ' ) -> 'DictStrAny' schema_json def schema_json ( * , by_alias : bool = True , ref_template : 'unicode' = '#/definitions/ {model} ' , ** dumps_kwargs : Any ) -> 'unicode' update_forward_refs def update_forward_refs ( ** localns : Any ) -> None Try to update ForwardRefs on fields based on this Model, globalns and localns. validate def validate ( value : Any ) -> 'Model' Instance variables fields Methods copy def copy ( self : 'Model' , * , include : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' )] = None , exclude : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' )] = None , update : 'DictStrAny' = None , deep : bool = False ) -> 'Model' Duplicate a model, optionally choose which fields to include, exclude and change. :param include: fields to include in new model :param exclude: fields to exclude from new model, as with values this takes precedence over include :param update: values to change/add in the new model. Note: the data is not validated before creating the new model: you should trust this data :param deep: set to True to make a deep copy of the model :return: new model instance dict def dict ( self , * , include : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' )] = None , exclude : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' )] = None , by_alias : bool = False , skip_defaults : bool = None , exclude_unset : bool = False , exclude_defaults : bool = False , exclude_none : bool = False ) -> 'DictStrAny' Generate a dictionary representation of the model, optionally specifying which fields to include or exclude. json def json ( self , * , include : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' )] = None , exclude : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' )] = None , by_alias : bool = False , skip_defaults : bool = None , exclude_unset : bool = False , exclude_defaults : bool = False , exclude_none : bool = False , encoder : Optional [ Callable [[ Any ], Any ]] = None , ** dumps_kwargs : Any ) -> 'unicode' Generate a JSON representation of the model, include and exclude arguments as per dict() . encoder is an optional function to supply as default to json.dumps(), other arguments as per json.dumps() . to_string def to_string ( self , pretty : bool = False ) -> 'unicode' BlockChain class BlockChain ( ) Simple class to emulate a blockchain View Source class BlockChain : \"\"\"Simple class to emulate a blockchain\"\"\" __ slots__ = { \"chain\" : \"List of different Block objects making up the blockchain\" , \"current_transactions\" : \"List of Transaction objects to be added to the next block\" , \"nodes\" : \"Set of different nodes registered on the network\" , } def __ init__ ( self ) : self . chain : List [ Block ] = [] self . current_transactions: List [ Transaction ] = [] self . nodes : Set [ str ] = set () logger . debug ( \"Initiating first block\" ) self . add_block ( previous_hash = 1 , proof = 100 ) def add_block ( self , previous_hash: Optional [ str ] = None , proof : int = None ) -> Block : \"\"\" Create a new block and add it to the chain. Args: previous_hash (Optional[str]): hash of the previous block in the chain. proof (int): the proof given by the proof of work algorithm. Returns: The new block. \"\"\" logger . debug ( \"Creating a new block\" ) block = Block ( index = len ( self . chain ) + 1 , timestamp = time (), transactions = self . current_transactions , proof = proof , previous_hash = previous_hash or self . hash ( self . chain [ - 1 ]), ) logger . debug ( \"Resetting the current list of transations\" ) self . current_transactions = [] logger . debug ( \"Adding block to the chain\" ) self . chain . append ( block ) logger . success ( \"Added block to the chain\" ) return block def add_transaction ( self , sender : str = None , recipient : str = None , amount : float = None ) -> int : \"\"\" Adds a new transaction to the list of transactions. Args: sender (str): address of the sender. recipient (str): address of the recipient. amount (float): the amount of the transaction. Returns: An integer containing the index of the block that will hold this transaction. \"\"\" logger . debug ( \"Adding transaction to the list of current transactions\" ) self . current_transactions . append ( Transaction ( sender = sender , recipient = recipient , amount = amount ) ) return self . last_block . index # index is already incremented in block creation @property def last_block ( self ) -> Block : \"\"\" Returns the last block in the chain. Returns: The last block in the chain. \"\"\" return self . chain [ - 1 ] @staticmethod def hash ( block : Block ) -> str : \"\"\" Hashes a new block. Args: block (Block): the block's contents. Returns: The block's hash. \"\"\" # Ordering the block dict for consistent hashes logger . debug ( \"Ordering block dictionary and dumping to json\" ) block_bytes: bytes = block . schema_json (). encode () logger . debug ( \"Hashing dumped block\" ) return hashlib . sha256 ( block_bytes ). hexdigest () @staticmethod def validate_proof ( last_proof: int = None , new_proof: int = None ) -> bool : \"\"\" Validates a proof: does hash(last_proof, new_proof) contain 4 leading zeroes? Args: last_proof (int): the previous proof in the chain. new_proof (int): the new proof. Returns: True if new_proof is validated, False otherwise. \"\"\" logger . trace ( \"Checking proof validity\" ) guess : bytes = f \"{last_proof}{new_proof}\" . encode () guess_hash: str = hashlib . sha256 ( guess ). hexdigest () if guess_hash [ : 4 ] == \"0000\" : logger . debug ( \"Proof iteration is valid\" ) return True logger . trace ( \"Proof is invalid\" ) return False def proof_of_work ( self , last_proof: int = None ) -> int : \"\"\" Simple Proof of Work Algorithm: - Find a number p' such that hash(pp') has leading 4 zeroes, where p is the previous p' - p is the previous proof, and p' is the new proof Args: last_proof (int): the previous proof in the chain. Returns: The new proof, an integer. \"\"\" proof : int = 0 while self . validate_proof ( last_proof = last_proof , new_proof = proof ) is False : logger . trace ( \"Proof didn't pass, iterating\" ) proof += 1 logger . debug ( \"Successfully mined block proof\" ) return proof def register_node ( self , address : str = None ) -> None : \"\"\" Register a new node as part of the network by adding it to the list of nodes. Args: address (str): string, address of node to register. Eg. 'http://192.168.0.5:5000' Returns: Nothing, adds in place. \"\"\" logger . debug ( f \"Parsing new node address '{address}'\" ) parsed_url: Union [ ParseResult , ParseResultBytes ] = urlparse ( address ) node_netloc: str = str ( parsed_url . netloc ) logger . debug ( f \"Netloc for new node is {node_netloc}\" ) logger . debug ( f \"{self.nodes}\" ) if node_netloc in self . nodes : logger . warning ( f \"Node at {address} is already registered, skipping\" ) else : logger . debug ( f \"Adding new element with address {address} to network's registered nodes\" ) self . nodes . add ( node_netloc ) def validate_chain ( self , chain : List [ Block ]) -> bool : \"\"\" Determine if a given blockchain from any arbitrary node in the network is valid. Args: chain (List[Block]): a complete blockchain (list of blocks as dicts). Returns: True if the chain is valid, False otherwise \"\"\" logger . trace ( \"Determining chain validity, starting with first non-dummy block\" ) for previous_block , inspected_block in zip ( chain [:- 1 ], chain [ 1 : ]) : logger . trace ( \"Checking block's hash\" ) if inspected_block . previous_hash ! = self . hash ( previous_block ) : logger . error ( f \"Invalid block tag 'previous_hash': {inspected_block.previous_hash}\" ) return False logger . trace ( \"Checking block's proof of work\" ) if not self . validate_proof ( last_proof = previous_block . proof , new_proof = inspected_block . proof ) : logger . error ( f \"Discrepancy between last block's proof '{previous_block.proof}' and \" f \"inspected block's proof '{inspected_block.proof}'\" ) return False logger . trace ( \"Moving on to next block\" ) logger . debug ( \"Chain is valid\" ) return True def resolve_conflicts ( self ) -> bool : \"\"\" This is the Consensus Algorithm. It resolves conflicts by replacing the node's chain with the longest valid one in the network. Returns: True if the node's chain was replaced, False otherwise \"\"\" neighbouring_nodes = self . nodes new_chain: List [ Block ] = None max_length: int = len ( self . chain ) # initialize with this node's length logger.debug(\"Verifying chains from all nodes in the network\") for node in neighbouring_nodes: logger.debug(f\"Querying node ' { node } ' for its full chain\") node_chain_response = requests.get(f\"http://{node}/chain\") if node_chain_response.status_code == 200: logger.trace(\"Full chain received\") length = node_chain_response.json()[\"length\"] chain = node_chain_response.json()[\"chain\"] logger.trace(\"Checking if requested chain is valid and longer than mine\") if length > max_length and self.validate_chain(chain): max_length = length new_chain = chain if new_chain: logger.info(\"Found a valid chain longer than this node's , adopting it now \") self.chain = new_chain return True logger.info(\" No valid chain was longer than this node ' s \" ) return False Static methods hash def hash ( block : toychain . blockchain . Block ) -> str Hashes a new block. Args: block (Block): the block's contents. Returns: The block's hash. View Source @staticmethod def hash ( block : Block ) -> str : \"\"\" Hashes a new block. Args: block (Block): the block's contents. Returns: The block's hash. \"\"\" # Ordering the block dict for consistent hashes logger . debug ( \"Ordering block dictionary and dumping to json\" ) block_bytes : bytes = block . schema_json (). encode () logger . debug ( \"Hashing dumped block\" ) return hashlib . sha256 ( block_bytes ). hexdigest () validate_proof def validate_proof ( last_proof : int = None , new_proof : int = None ) -> bool Validates a proof: does hash(last_proof, new_proof) contain 4 leading zeroes? Args: last_proof (int): the previous proof in the chain. new_proof (int): the new proof. Returns: True if new_proof is validated, False otherwise. View Source @staticmethod def validate_proof ( last_proof : int = None , new_proof : int = None ) -> bool : \"\"\" Validates a proof: does hash(last_proof, new_proof) contain 4 leading zeroes? Args: last_proof (int): the previous proof in the chain. new_proof (int): the new proof. Returns: True if new_proof is validated, False otherwise. \"\"\" logger . trace ( \"Checking proof validity\" ) guess : bytes = f \"{last_proof}{new_proof}\" . encode () guess_hash : str = hashlib . sha256 ( guess ). hexdigest () if guess_hash [ :4 ] == \"0000\" : logger . debug ( \"Proof iteration is valid\" ) return True logger . trace ( \"Proof is invalid\" ) return False Instance variables chain current_transactions last_block Returns the last block in the chain. Returns: The last block in the chain. nodes Methods add_block def add_block ( self , previous_hash : Optional [ str ] = None , proof : int = None ) -> toychain . blockchain . Block Create a new block and add it to the chain. Args: previous_hash (Optional[str]): hash of the previous block in the chain. proof (int): the proof given by the proof of work algorithm. Returns: The new block. View Source def add_block ( self , previous_hash : Optional [ str ] = None , proof : int = None ) -> Block : \"\"\" Create a new block and add it to the chain. Args: previous_hash (Optional[str]): hash of the previous block in the chain. proof (int): the proof given by the proof of work algorithm. Returns: The new block. \"\"\" logger . debug ( \"Creating a new block\" ) block = Block ( index = len ( self . chain ) + 1 , timestamp = time (), transactions = self . current_transactions , proof = proof , previous_hash = previous_hash or self . hash ( self . chain [ -1 ] ), ) logger . debug ( \"Resetting the current list of transations\" ) self . current_transactions = [] logger . debug ( \"Adding block to the chain\" ) self . chain . append ( block ) logger . success ( \"Added block to the chain\" ) return block add_transaction def add_transaction ( self , sender : str = None , recipient : str = None , amount : float = None ) -> int Adds a new transaction to the list of transactions. Args: sender (str): address of the sender. recipient (str): address of the recipient. amount (float): the amount of the transaction. Returns: An integer containing the index of the block that will hold this transaction. View Source def add_transaction ( self , sender : str = None , recipient : str = None , amount : float = None ) -> int : \"\"\" Adds a new transaction to the list of transactions. Args: sender (str): address of the sender. recipient (str): address of the recipient. amount (float): the amount of the transaction. Returns: An integer containing the index of the block that will hold this transaction. \"\"\" logger . debug ( \"Adding transaction to the list of current transactions\" ) self . current_transactions . append ( Transaction ( sender = sender , recipient = recipient , amount = amount ) ) return self . last_block . index # index is already incremented in block creation proof_of_work def proof_of_work ( self , last_proof : int = None ) -> int Simple Proof of Work Algorithm: - Find a number p' such that hash(pp') has leading 4 zeroes, where p is the previous p' - p is the previous proof, and p' is the new proof Args: last_proof (int): the previous proof in the chain. Returns: The new proof, an integer. View Source def proof_of_work ( self , last_proof : int = None ) -> int : \"\"\" Simple Proof of Work Algorithm: - Find a number p' such that hash(pp') has leading 4 zeroes, where p is the previous p' - p is the previous proof, and p' is the new proof Args: last_proof (int): the previous proof in the chain. Returns: The new proof, an integer. \"\"\" proof : int = 0 while self . validate_proof ( last_proof = last_proof , new_proof = proof ) is False : logger . trace ( \"Proof didn't pass, iterating\" ) proof += 1 logger . debug ( \"Successfully mined block proof\" ) return proof register_node def register_node ( self , address : str = None ) -> None Register a new node as part of the network by adding it to the list of nodes. Args: address (str): string, address of node to register. Eg. ' http://192.168.0.5:5000 ' Returns: Nothing, adds in place. View Source def register_node ( self , address: str = None ) -> None: \"\"\" Register a new node as part of the network by adding it to the list of nodes . Args: address ( str ) : string , address of node to register . Eg . ' http: //192.168.0.5:5000' Returns: Nothing , adds in place . \"\"\" logger . debug ( f \"Parsing new node address '{address}'\" ) parsed_url: Union [ ParseResult , ParseResultBytes ] = urlparse ( address ) node_netloc: str = str ( parsed_url . netloc ) logger . debug ( f \"Netloc for new node is {node_netloc}\" ) logger . debug ( f \"{self.nodes}\" ) if node_netloc in self . nodes: logger . warning ( f \"Node at {address} is already registered, skipping\" ) else : logger . debug ( f \"Adding new element with address {address} to network's registered nodes\" ) self . nodes . add ( node_netloc ) resolve_conflicts def resolve_conflicts ( self ) -> bool This is the Consensus Algorithm. It resolves conflicts by replacing the node's chain with the longest valid one in the network. Returns: True if the node's chain was replaced, False otherwise View Source def resolve_conflicts ( self ) -> bool : \"\"\" This is the Consensus Algorithm. It resolves conflicts by replacing the node's chain with the longest valid one in the network. Returns: True if the node's chain was replaced, False otherwise \"\"\" neighbouring_nodes = self . nodes new_chain : List [ Block ] = None max_length : int = len ( self . chain ) # initialize with this node 's length logger.debug(\"Verifying chains from all nodes in the network\") for node in neighbouring_nodes: logger.debug(f\"Querying node ' { node } ' for its full chain\") node_chain_response = requests.get(f\"http://{node}/chain\") if node_chain_response.status_code == 200: logger.trace(\"Full chain received\") length = node_chain_response.json()[\"length\"] chain = node_chain_response.json()[\"chain\"] logger.trace(\"Checking if requested chain is valid and longer than mine\") if length > max_length and self.validate_chain(chain): max_length = length new_chain = chain if new_chain: logger.info(\"Found a valid chain longer than this node' s , adopting it now \") self.chain = new_chain return True logger.info(\" No valid chain was longer than this node ' s \" ) return False validate_chain def validate_chain ( self , chain : List [ toychain . blockchain . Block ] ) -> bool Determine if a given blockchain from any arbitrary node in the network is valid. Args: chain (List[Block]): a complete blockchain (list of blocks as dicts). Returns: True if the chain is valid, False otherwise View Source def validate_chain ( self , chain : List [ Block ]) -> bool : \"\"\" Determine if a given blockchain from any arbitrary node in the network is valid. Args: chain (List[Block]): a complete blockchain (list of blocks as dicts). Returns: True if the chain is valid, False otherwise \"\"\" logger . trace ( \"Determining chain validity, starting with first non-dummy block\" ) for previous_block , inspected_block in zip ( chain [:- 1 ], chain [ 1 : ]) : logger . trace ( \"Checking block's hash\" ) if inspected_block . previous_hash ! = self . hash ( previous_block ) : logger . error ( f \"Invalid block tag 'previous_hash': {inspected_block.previous_hash}\" ) return False logger . trace ( \"Checking block's proof of work\" ) if not self . validate_proof ( last_proof = previous_block . proof , new_proof = inspected_block . proof ) : logger . error ( f \"Discrepancy between last block's proof '{previous_block.proof}' and \" f \"inspected block's proof '{inspected_block.proof}'\" ) return False logger . trace ( \"Moving on to next block\" ) logger . debug ( \"Chain is valid\" ) return True Transaction class Transaction ( __pydantic_self__ , ** data : Any ) View Source class Transaction ( BaseModel ): sender: str recipient: str amount: float Ancestors (in MRO) pydantic.main.BaseModel pydantic.utils.Representation Class variables Config Static methods construct def construct ( _fields_set : Optional [ ForwardRef ( 'SetStr' )] = None , ** values : Any ) -> 'Model' Creates a new model setting dict and fields_set from trusted or pre-validated data. Default values are respected, but no other validation is performed. from_orm def from_orm ( obj : Any ) -> 'Model' parse_file def parse_file ( path : Union [ str , pathlib . Path ], * , content_type : 'unicode' = None , encoding : 'unicode' = 'utf8' , proto : pydantic . parse . Protocol = None , allow_pickle : bool = False ) -> 'Model' parse_obj def parse_obj ( obj : Any ) -> 'Model' parse_raw def parse_raw ( b : Union [ str , bytes ], * , content_type : 'unicode' = None , encoding : 'unicode' = 'utf8' , proto : pydantic . parse . Protocol = None , allow_pickle : bool = False ) -> 'Model' schema def schema ( by_alias : bool = True , ref_template : 'unicode' = '#/definitions/ {model} ' ) -> 'DictStrAny' schema_json def schema_json ( * , by_alias : bool = True , ref_template : 'unicode' = '#/definitions/ {model} ' , ** dumps_kwargs : Any ) -> 'unicode' update_forward_refs def update_forward_refs ( ** localns : Any ) -> None Try to update ForwardRefs on fields based on this Model, globalns and localns. validate def validate ( value : Any ) -> 'Model' Instance variables fields Methods copy def copy ( self : 'Model' , * , include : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' )] = None , exclude : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' )] = None , update : 'DictStrAny' = None , deep : bool = False ) -> 'Model' Duplicate a model, optionally choose which fields to include, exclude and change. :param include: fields to include in new model :param exclude: fields to exclude from new model, as with values this takes precedence over include :param update: values to change/add in the new model. Note: the data is not validated before creating the new model: you should trust this data :param deep: set to True to make a deep copy of the model :return: new model instance dict def dict ( self , * , include : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' )] = None , exclude : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' )] = None , by_alias : bool = False , skip_defaults : bool = None , exclude_unset : bool = False , exclude_defaults : bool = False , exclude_none : bool = False ) -> 'DictStrAny' Generate a dictionary representation of the model, optionally specifying which fields to include or exclude. json def json ( self , * , include : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' )] = None , exclude : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' )] = None , by_alias : bool = False , skip_defaults : bool = None , exclude_unset : bool = False , exclude_defaults : bool = False , exclude_none : bool = False , encoder : Optional [ Callable [[ Any ], Any ]] = None , ** dumps_kwargs : Any ) -> 'unicode' Generate a JSON representation of the model, include and exclude arguments as per dict() . encoder is an optional function to supply as default to json.dumps(), other arguments as per json.dumps() . to_string def to_string ( self , pretty : bool = False ) -> 'unicode'","title":"Blockchain"},{"location":"reference/toychain/blockchain/#module-toychainblockchain","text":"Simple emulation of a blockchain. View Source \"\"\" Simple emulation of a blockchain. \"\"\" import hashlib from time import time from typing import List , Optional , Set , Union from urllib . parse import ParseResult , ParseResultBytes , urlparse import requests from loguru import logger from pydantic import BaseModel class Transaction ( BaseModel ) : sender : str recipient : str amount : float class Block ( BaseModel ) : index : int timestamp : float transactions : List [ Transaction ] proof : Optional [ int ] previous_hash: str class BlockChain : \"\"\"Simple class to emulate a blockchain\"\"\" __ slots__ = { \"chain\" : \"List of different Block objects making up the blockchain\" , \"current_transactions\" : \"List of Transaction objects to be added to the next block\" , \"nodes\" : \"Set of different nodes registered on the network\" , } def __ init__ ( self ) : self . chain : List [ Block ] = [] self . current_transactions: List [ Transaction ] = [] self . nodes : Set [ str ] = set () logger . debug ( \"Initiating first block\" ) self . add_block ( previous_hash = 1 , proof = 100 ) def add_block ( self , previous_hash: Optional [ str ] = None , proof : int = None ) -> Block : \"\"\" Create a new block and add it to the chain. Args: previous_hash (Optional[str]): hash of the previous block in the chain. proof (int): the proof given by the proof of work algorithm. Returns: The new block. \"\"\" logger . debug ( \"Creating a new block\" ) block = Block ( index = len ( self . chain ) + 1 , timestamp = time (), transactions = self . current_transactions , proof = proof , previous_hash = previous_hash or self . hash ( self . chain [ - 1 ]), ) logger . debug ( \"Resetting the current list of transations\" ) self . current_transactions = [] logger . debug ( \"Adding block to the chain\" ) self . chain . append ( block ) logger . success ( \"Added block to the chain\" ) return block def add_transaction ( self , sender : str = None , recipient : str = None , amount : float = None ) -> int : \"\"\" Adds a new transaction to the list of transactions. Args: sender (str): address of the sender. recipient (str): address of the recipient. amount (float): the amount of the transaction. Returns: An integer containing the index of the block that will hold this transaction. \"\"\" logger . debug ( \"Adding transaction to the list of current transactions\" ) self . current_transactions . append ( Transaction ( sender = sender , recipient = recipient , amount = amount ) ) return self . last_block . index # index is already incremented in block creation @property def last_block ( self ) -> Block : \"\"\" Returns the last block in the chain. Returns: The last block in the chain. \"\"\" return self . chain [ - 1 ] @staticmethod def hash ( block : Block ) -> str : \"\"\" Hashes a new block. Args: block (Block): the block's contents. Returns: The block's hash. \"\"\" # Ordering the block dict for consistent hashes logger . debug ( \"Ordering block dictionary and dumping to json\" ) block_bytes: bytes = block . schema_json (). encode () logger . debug ( \"Hashing dumped block\" ) return hashlib . sha256 ( block_bytes ). hexdigest () @staticmethod def validate_proof ( last_proof: int = None , new_proof: int = None ) -> bool : \"\"\" Validates a proof: does hash(last_proof, new_proof) contain 4 leading zeroes? Args: last_proof (int): the previous proof in the chain. new_proof (int): the new proof. Returns: True if new_proof is validated, False otherwise. \"\"\" logger . trace ( \"Checking proof validity\" ) guess : bytes = f \"{last_proof}{new_proof}\" . encode () guess_hash: str = hashlib . sha256 ( guess ). hexdigest () if guess_hash [ : 4 ] == \"0000\" : logger . debug ( \"Proof iteration is valid\" ) return True logger . trace ( \"Proof is invalid\" ) return False def proof_of_work ( self , last_proof: int = None ) -> int : \"\"\" Simple Proof of Work Algorithm: - Find a number p' such that hash(pp') has leading 4 zeroes, where p is the previous p' - p is the previous proof, and p' is the new proof Args: last_proof (int): the previous proof in the chain. Returns: The new proof, an integer. \"\"\" proof : int = 0 while self . validate_proof ( last_proof = last_proof , new_proof = proof ) is False : logger . trace ( \"Proof didn't pass, iterating\" ) proof += 1 logger . debug ( \"Successfully mined block proof\" ) return proof def register_node ( self , address : str = None ) -> None : \"\"\" Register a new node as part of the network by adding it to the list of nodes. Args: address (str): string, address of node to register. Eg. 'http://192.168.0.5:5000' Returns: Nothing, adds in place. \"\"\" logger . debug ( f \"Parsing new node address '{address}'\" ) parsed_url: Union [ ParseResult , ParseResultBytes ] = urlparse ( address ) node_netloc: str = str ( parsed_url . netloc ) logger . debug ( f \"Netloc for new node is {node_netloc}\" ) logger . debug ( f \"{self.nodes}\" ) if node_netloc in self . nodes : logger . warning ( f \"Node at {address} is already registered, skipping\" ) else : logger . debug ( f \"Adding new element with address {address} to network's registered nodes\" ) self . nodes . add ( node_netloc ) def validate_chain ( self , chain : List [ Block ]) -> bool : \"\"\" Determine if a given blockchain from any arbitrary node in the network is valid. Args: chain (List[Block]): a complete blockchain (list of blocks as dicts). Returns: True if the chain is valid, False otherwise \"\"\" logger . trace ( \"Determining chain validity, starting with first non-dummy block\" ) for previous_block , inspected_block in zip ( chain [:- 1 ], chain [ 1 : ]) : logger . trace ( \"Checking block's hash\" ) if inspected_block . previous_hash ! = self . hash ( previous_block ) : logger . error ( f \"Invalid block tag 'previous_hash': {inspected_block.previous_hash}\" ) return False logger . trace ( \"Checking block's proof of work\" ) if not self . validate_proof ( last_proof = previous_block . proof , new_proof = inspected_block . proof ) : logger . error ( f \"Discrepancy between last block's proof '{previous_block.proof}' and \" f \"inspected block's proof '{inspected_block.proof}'\" ) return False logger . trace ( \"Moving on to next block\" ) logger . debug ( \"Chain is valid\" ) return True def resolve_conflicts ( self ) -> bool : \"\"\" This is the Consensus Algorithm. It resolves conflicts by replacing the node's chain with the longest valid one in the network. Returns: True if the node's chain was replaced, False otherwise \"\"\" neighbouring_nodes = self . nodes new_chain: List [ Block ] = None max_length: int = len ( self . chain ) # initialize with this node's length logger.debug(\"Verifying chains from all nodes in the network\") for node in neighbouring_nodes: logger.debug(f\"Querying node ' { node } ' for its full chain\") node_chain_response = requests.get(f\"http://{node}/chain\") if node_chain_response.status_code == 200: logger.trace(\"Full chain received\") length = node_chain_response.json()[\"length\"] chain = node_chain_response.json()[\"chain\"] logger.trace(\"Checking if requested chain is valid and longer than mine\") if length > max_length and self.validate_chain(chain): max_length = length new_chain = chain if new_chain: logger.info(\"Found a valid chain longer than this node's , adopting it now \") self.chain = new_chain return True logger.info(\" No valid chain was longer than this node ' s \" ) return False","title":"Module toychain.blockchain"},{"location":"reference/toychain/blockchain/#classes","text":"","title":"Classes"},{"location":"reference/toychain/blockchain/#block","text":"class Block ( __pydantic_self__ , ** data : Any ) View Source class Block ( BaseModel ) : index : int timestamp : float transactions : List [ Transaction ] proof : Optional [ int ] previous_hash : str","title":"Block"},{"location":"reference/toychain/blockchain/#ancestors-in-mro","text":"pydantic.main.BaseModel pydantic.utils.Representation","title":"Ancestors (in MRO)"},{"location":"reference/toychain/blockchain/#class-variables","text":"Config","title":"Class variables"},{"location":"reference/toychain/blockchain/#static-methods","text":"","title":"Static methods"},{"location":"reference/toychain/blockchain/#construct","text":"def construct ( _fields_set : Optional [ ForwardRef ( 'SetStr' )] = None , ** values : Any ) -> 'Model' Creates a new model setting dict and fields_set from trusted or pre-validated data. Default values are respected, but no other validation is performed.","title":"construct"},{"location":"reference/toychain/blockchain/#from_orm","text":"def from_orm ( obj : Any ) -> 'Model'","title":"from_orm"},{"location":"reference/toychain/blockchain/#parse_file","text":"def parse_file ( path : Union [ str , pathlib . Path ], * , content_type : 'unicode' = None , encoding : 'unicode' = 'utf8' , proto : pydantic . parse . Protocol = None , allow_pickle : bool = False ) -> 'Model'","title":"parse_file"},{"location":"reference/toychain/blockchain/#parse_obj","text":"def parse_obj ( obj : Any ) -> 'Model'","title":"parse_obj"},{"location":"reference/toychain/blockchain/#parse_raw","text":"def parse_raw ( b : Union [ str , bytes ], * , content_type : 'unicode' = None , encoding : 'unicode' = 'utf8' , proto : pydantic . parse . Protocol = None , allow_pickle : bool = False ) -> 'Model'","title":"parse_raw"},{"location":"reference/toychain/blockchain/#schema","text":"def schema ( by_alias : bool = True , ref_template : 'unicode' = '#/definitions/ {model} ' ) -> 'DictStrAny'","title":"schema"},{"location":"reference/toychain/blockchain/#schema_json","text":"def schema_json ( * , by_alias : bool = True , ref_template : 'unicode' = '#/definitions/ {model} ' , ** dumps_kwargs : Any ) -> 'unicode'","title":"schema_json"},{"location":"reference/toychain/blockchain/#update_forward_refs","text":"def update_forward_refs ( ** localns : Any ) -> None Try to update ForwardRefs on fields based on this Model, globalns and localns.","title":"update_forward_refs"},{"location":"reference/toychain/blockchain/#validate","text":"def validate ( value : Any ) -> 'Model'","title":"validate"},{"location":"reference/toychain/blockchain/#instance-variables","text":"fields","title":"Instance variables"},{"location":"reference/toychain/blockchain/#methods","text":"","title":"Methods"},{"location":"reference/toychain/blockchain/#copy","text":"def copy ( self : 'Model' , * , include : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' )] = None , exclude : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' )] = None , update : 'DictStrAny' = None , deep : bool = False ) -> 'Model' Duplicate a model, optionally choose which fields to include, exclude and change. :param include: fields to include in new model :param exclude: fields to exclude from new model, as with values this takes precedence over include :param update: values to change/add in the new model. Note: the data is not validated before creating the new model: you should trust this data :param deep: set to True to make a deep copy of the model :return: new model instance","title":"copy"},{"location":"reference/toychain/blockchain/#dict","text":"def dict ( self , * , include : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' )] = None , exclude : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' )] = None , by_alias : bool = False , skip_defaults : bool = None , exclude_unset : bool = False , exclude_defaults : bool = False , exclude_none : bool = False ) -> 'DictStrAny' Generate a dictionary representation of the model, optionally specifying which fields to include or exclude.","title":"dict"},{"location":"reference/toychain/blockchain/#json","text":"def json ( self , * , include : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' )] = None , exclude : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' )] = None , by_alias : bool = False , skip_defaults : bool = None , exclude_unset : bool = False , exclude_defaults : bool = False , exclude_none : bool = False , encoder : Optional [ Callable [[ Any ], Any ]] = None , ** dumps_kwargs : Any ) -> 'unicode' Generate a JSON representation of the model, include and exclude arguments as per dict() . encoder is an optional function to supply as default to json.dumps(), other arguments as per json.dumps() .","title":"json"},{"location":"reference/toychain/blockchain/#to_string","text":"def to_string ( self , pretty : bool = False ) -> 'unicode'","title":"to_string"},{"location":"reference/toychain/blockchain/#blockchain","text":"class BlockChain ( ) Simple class to emulate a blockchain View Source class BlockChain : \"\"\"Simple class to emulate a blockchain\"\"\" __ slots__ = { \"chain\" : \"List of different Block objects making up the blockchain\" , \"current_transactions\" : \"List of Transaction objects to be added to the next block\" , \"nodes\" : \"Set of different nodes registered on the network\" , } def __ init__ ( self ) : self . chain : List [ Block ] = [] self . current_transactions: List [ Transaction ] = [] self . nodes : Set [ str ] = set () logger . debug ( \"Initiating first block\" ) self . add_block ( previous_hash = 1 , proof = 100 ) def add_block ( self , previous_hash: Optional [ str ] = None , proof : int = None ) -> Block : \"\"\" Create a new block and add it to the chain. Args: previous_hash (Optional[str]): hash of the previous block in the chain. proof (int): the proof given by the proof of work algorithm. Returns: The new block. \"\"\" logger . debug ( \"Creating a new block\" ) block = Block ( index = len ( self . chain ) + 1 , timestamp = time (), transactions = self . current_transactions , proof = proof , previous_hash = previous_hash or self . hash ( self . chain [ - 1 ]), ) logger . debug ( \"Resetting the current list of transations\" ) self . current_transactions = [] logger . debug ( \"Adding block to the chain\" ) self . chain . append ( block ) logger . success ( \"Added block to the chain\" ) return block def add_transaction ( self , sender : str = None , recipient : str = None , amount : float = None ) -> int : \"\"\" Adds a new transaction to the list of transactions. Args: sender (str): address of the sender. recipient (str): address of the recipient. amount (float): the amount of the transaction. Returns: An integer containing the index of the block that will hold this transaction. \"\"\" logger . debug ( \"Adding transaction to the list of current transactions\" ) self . current_transactions . append ( Transaction ( sender = sender , recipient = recipient , amount = amount ) ) return self . last_block . index # index is already incremented in block creation @property def last_block ( self ) -> Block : \"\"\" Returns the last block in the chain. Returns: The last block in the chain. \"\"\" return self . chain [ - 1 ] @staticmethod def hash ( block : Block ) -> str : \"\"\" Hashes a new block. Args: block (Block): the block's contents. Returns: The block's hash. \"\"\" # Ordering the block dict for consistent hashes logger . debug ( \"Ordering block dictionary and dumping to json\" ) block_bytes: bytes = block . schema_json (). encode () logger . debug ( \"Hashing dumped block\" ) return hashlib . sha256 ( block_bytes ). hexdigest () @staticmethod def validate_proof ( last_proof: int = None , new_proof: int = None ) -> bool : \"\"\" Validates a proof: does hash(last_proof, new_proof) contain 4 leading zeroes? Args: last_proof (int): the previous proof in the chain. new_proof (int): the new proof. Returns: True if new_proof is validated, False otherwise. \"\"\" logger . trace ( \"Checking proof validity\" ) guess : bytes = f \"{last_proof}{new_proof}\" . encode () guess_hash: str = hashlib . sha256 ( guess ). hexdigest () if guess_hash [ : 4 ] == \"0000\" : logger . debug ( \"Proof iteration is valid\" ) return True logger . trace ( \"Proof is invalid\" ) return False def proof_of_work ( self , last_proof: int = None ) -> int : \"\"\" Simple Proof of Work Algorithm: - Find a number p' such that hash(pp') has leading 4 zeroes, where p is the previous p' - p is the previous proof, and p' is the new proof Args: last_proof (int): the previous proof in the chain. Returns: The new proof, an integer. \"\"\" proof : int = 0 while self . validate_proof ( last_proof = last_proof , new_proof = proof ) is False : logger . trace ( \"Proof didn't pass, iterating\" ) proof += 1 logger . debug ( \"Successfully mined block proof\" ) return proof def register_node ( self , address : str = None ) -> None : \"\"\" Register a new node as part of the network by adding it to the list of nodes. Args: address (str): string, address of node to register. Eg. 'http://192.168.0.5:5000' Returns: Nothing, adds in place. \"\"\" logger . debug ( f \"Parsing new node address '{address}'\" ) parsed_url: Union [ ParseResult , ParseResultBytes ] = urlparse ( address ) node_netloc: str = str ( parsed_url . netloc ) logger . debug ( f \"Netloc for new node is {node_netloc}\" ) logger . debug ( f \"{self.nodes}\" ) if node_netloc in self . nodes : logger . warning ( f \"Node at {address} is already registered, skipping\" ) else : logger . debug ( f \"Adding new element with address {address} to network's registered nodes\" ) self . nodes . add ( node_netloc ) def validate_chain ( self , chain : List [ Block ]) -> bool : \"\"\" Determine if a given blockchain from any arbitrary node in the network is valid. Args: chain (List[Block]): a complete blockchain (list of blocks as dicts). Returns: True if the chain is valid, False otherwise \"\"\" logger . trace ( \"Determining chain validity, starting with first non-dummy block\" ) for previous_block , inspected_block in zip ( chain [:- 1 ], chain [ 1 : ]) : logger . trace ( \"Checking block's hash\" ) if inspected_block . previous_hash ! = self . hash ( previous_block ) : logger . error ( f \"Invalid block tag 'previous_hash': {inspected_block.previous_hash}\" ) return False logger . trace ( \"Checking block's proof of work\" ) if not self . validate_proof ( last_proof = previous_block . proof , new_proof = inspected_block . proof ) : logger . error ( f \"Discrepancy between last block's proof '{previous_block.proof}' and \" f \"inspected block's proof '{inspected_block.proof}'\" ) return False logger . trace ( \"Moving on to next block\" ) logger . debug ( \"Chain is valid\" ) return True def resolve_conflicts ( self ) -> bool : \"\"\" This is the Consensus Algorithm. It resolves conflicts by replacing the node's chain with the longest valid one in the network. Returns: True if the node's chain was replaced, False otherwise \"\"\" neighbouring_nodes = self . nodes new_chain: List [ Block ] = None max_length: int = len ( self . chain ) # initialize with this node's length logger.debug(\"Verifying chains from all nodes in the network\") for node in neighbouring_nodes: logger.debug(f\"Querying node ' { node } ' for its full chain\") node_chain_response = requests.get(f\"http://{node}/chain\") if node_chain_response.status_code == 200: logger.trace(\"Full chain received\") length = node_chain_response.json()[\"length\"] chain = node_chain_response.json()[\"chain\"] logger.trace(\"Checking if requested chain is valid and longer than mine\") if length > max_length and self.validate_chain(chain): max_length = length new_chain = chain if new_chain: logger.info(\"Found a valid chain longer than this node's , adopting it now \") self.chain = new_chain return True logger.info(\" No valid chain was longer than this node ' s \" ) return False","title":"BlockChain"},{"location":"reference/toychain/blockchain/#static-methods_1","text":"","title":"Static methods"},{"location":"reference/toychain/blockchain/#hash","text":"def hash ( block : toychain . blockchain . Block ) -> str Hashes a new block. Args: block (Block): the block's contents. Returns: The block's hash. View Source @staticmethod def hash ( block : Block ) -> str : \"\"\" Hashes a new block. Args: block (Block): the block's contents. Returns: The block's hash. \"\"\" # Ordering the block dict for consistent hashes logger . debug ( \"Ordering block dictionary and dumping to json\" ) block_bytes : bytes = block . schema_json (). encode () logger . debug ( \"Hashing dumped block\" ) return hashlib . sha256 ( block_bytes ). hexdigest ()","title":"hash"},{"location":"reference/toychain/blockchain/#validate_proof","text":"def validate_proof ( last_proof : int = None , new_proof : int = None ) -> bool Validates a proof: does hash(last_proof, new_proof) contain 4 leading zeroes? Args: last_proof (int): the previous proof in the chain. new_proof (int): the new proof. Returns: True if new_proof is validated, False otherwise. View Source @staticmethod def validate_proof ( last_proof : int = None , new_proof : int = None ) -> bool : \"\"\" Validates a proof: does hash(last_proof, new_proof) contain 4 leading zeroes? Args: last_proof (int): the previous proof in the chain. new_proof (int): the new proof. Returns: True if new_proof is validated, False otherwise. \"\"\" logger . trace ( \"Checking proof validity\" ) guess : bytes = f \"{last_proof}{new_proof}\" . encode () guess_hash : str = hashlib . sha256 ( guess ). hexdigest () if guess_hash [ :4 ] == \"0000\" : logger . debug ( \"Proof iteration is valid\" ) return True logger . trace ( \"Proof is invalid\" ) return False","title":"validate_proof"},{"location":"reference/toychain/blockchain/#instance-variables_1","text":"chain current_transactions last_block Returns the last block in the chain. Returns: The last block in the chain. nodes","title":"Instance variables"},{"location":"reference/toychain/blockchain/#methods_1","text":"","title":"Methods"},{"location":"reference/toychain/blockchain/#add_block","text":"def add_block ( self , previous_hash : Optional [ str ] = None , proof : int = None ) -> toychain . blockchain . Block Create a new block and add it to the chain. Args: previous_hash (Optional[str]): hash of the previous block in the chain. proof (int): the proof given by the proof of work algorithm. Returns: The new block. View Source def add_block ( self , previous_hash : Optional [ str ] = None , proof : int = None ) -> Block : \"\"\" Create a new block and add it to the chain. Args: previous_hash (Optional[str]): hash of the previous block in the chain. proof (int): the proof given by the proof of work algorithm. Returns: The new block. \"\"\" logger . debug ( \"Creating a new block\" ) block = Block ( index = len ( self . chain ) + 1 , timestamp = time (), transactions = self . current_transactions , proof = proof , previous_hash = previous_hash or self . hash ( self . chain [ -1 ] ), ) logger . debug ( \"Resetting the current list of transations\" ) self . current_transactions = [] logger . debug ( \"Adding block to the chain\" ) self . chain . append ( block ) logger . success ( \"Added block to the chain\" ) return block","title":"add_block"},{"location":"reference/toychain/blockchain/#add_transaction","text":"def add_transaction ( self , sender : str = None , recipient : str = None , amount : float = None ) -> int Adds a new transaction to the list of transactions. Args: sender (str): address of the sender. recipient (str): address of the recipient. amount (float): the amount of the transaction. Returns: An integer containing the index of the block that will hold this transaction. View Source def add_transaction ( self , sender : str = None , recipient : str = None , amount : float = None ) -> int : \"\"\" Adds a new transaction to the list of transactions. Args: sender (str): address of the sender. recipient (str): address of the recipient. amount (float): the amount of the transaction. Returns: An integer containing the index of the block that will hold this transaction. \"\"\" logger . debug ( \"Adding transaction to the list of current transactions\" ) self . current_transactions . append ( Transaction ( sender = sender , recipient = recipient , amount = amount ) ) return self . last_block . index # index is already incremented in block creation","title":"add_transaction"},{"location":"reference/toychain/blockchain/#proof_of_work","text":"def proof_of_work ( self , last_proof : int = None ) -> int Simple Proof of Work Algorithm: - Find a number p' such that hash(pp') has leading 4 zeroes, where p is the previous p' - p is the previous proof, and p' is the new proof Args: last_proof (int): the previous proof in the chain. Returns: The new proof, an integer. View Source def proof_of_work ( self , last_proof : int = None ) -> int : \"\"\" Simple Proof of Work Algorithm: - Find a number p' such that hash(pp') has leading 4 zeroes, where p is the previous p' - p is the previous proof, and p' is the new proof Args: last_proof (int): the previous proof in the chain. Returns: The new proof, an integer. \"\"\" proof : int = 0 while self . validate_proof ( last_proof = last_proof , new_proof = proof ) is False : logger . trace ( \"Proof didn't pass, iterating\" ) proof += 1 logger . debug ( \"Successfully mined block proof\" ) return proof","title":"proof_of_work"},{"location":"reference/toychain/blockchain/#register_node","text":"def register_node ( self , address : str = None ) -> None Register a new node as part of the network by adding it to the list of nodes. Args: address (str): string, address of node to register. Eg. ' http://192.168.0.5:5000 ' Returns: Nothing, adds in place. View Source def register_node ( self , address: str = None ) -> None: \"\"\" Register a new node as part of the network by adding it to the list of nodes . Args: address ( str ) : string , address of node to register . Eg . ' http: //192.168.0.5:5000' Returns: Nothing , adds in place . \"\"\" logger . debug ( f \"Parsing new node address '{address}'\" ) parsed_url: Union [ ParseResult , ParseResultBytes ] = urlparse ( address ) node_netloc: str = str ( parsed_url . netloc ) logger . debug ( f \"Netloc for new node is {node_netloc}\" ) logger . debug ( f \"{self.nodes}\" ) if node_netloc in self . nodes: logger . warning ( f \"Node at {address} is already registered, skipping\" ) else : logger . debug ( f \"Adding new element with address {address} to network's registered nodes\" ) self . nodes . add ( node_netloc )","title":"register_node"},{"location":"reference/toychain/blockchain/#resolve_conflicts","text":"def resolve_conflicts ( self ) -> bool This is the Consensus Algorithm. It resolves conflicts by replacing the node's chain with the longest valid one in the network. Returns: True if the node's chain was replaced, False otherwise View Source def resolve_conflicts ( self ) -> bool : \"\"\" This is the Consensus Algorithm. It resolves conflicts by replacing the node's chain with the longest valid one in the network. Returns: True if the node's chain was replaced, False otherwise \"\"\" neighbouring_nodes = self . nodes new_chain : List [ Block ] = None max_length : int = len ( self . chain ) # initialize with this node 's length logger.debug(\"Verifying chains from all nodes in the network\") for node in neighbouring_nodes: logger.debug(f\"Querying node ' { node } ' for its full chain\") node_chain_response = requests.get(f\"http://{node}/chain\") if node_chain_response.status_code == 200: logger.trace(\"Full chain received\") length = node_chain_response.json()[\"length\"] chain = node_chain_response.json()[\"chain\"] logger.trace(\"Checking if requested chain is valid and longer than mine\") if length > max_length and self.validate_chain(chain): max_length = length new_chain = chain if new_chain: logger.info(\"Found a valid chain longer than this node' s , adopting it now \") self.chain = new_chain return True logger.info(\" No valid chain was longer than this node ' s \" ) return False","title":"resolve_conflicts"},{"location":"reference/toychain/blockchain/#validate_chain","text":"def validate_chain ( self , chain : List [ toychain . blockchain . Block ] ) -> bool Determine if a given blockchain from any arbitrary node in the network is valid. Args: chain (List[Block]): a complete blockchain (list of blocks as dicts). Returns: True if the chain is valid, False otherwise View Source def validate_chain ( self , chain : List [ Block ]) -> bool : \"\"\" Determine if a given blockchain from any arbitrary node in the network is valid. Args: chain (List[Block]): a complete blockchain (list of blocks as dicts). Returns: True if the chain is valid, False otherwise \"\"\" logger . trace ( \"Determining chain validity, starting with first non-dummy block\" ) for previous_block , inspected_block in zip ( chain [:- 1 ], chain [ 1 : ]) : logger . trace ( \"Checking block's hash\" ) if inspected_block . previous_hash ! = self . hash ( previous_block ) : logger . error ( f \"Invalid block tag 'previous_hash': {inspected_block.previous_hash}\" ) return False logger . trace ( \"Checking block's proof of work\" ) if not self . validate_proof ( last_proof = previous_block . proof , new_proof = inspected_block . proof ) : logger . error ( f \"Discrepancy between last block's proof '{previous_block.proof}' and \" f \"inspected block's proof '{inspected_block.proof}'\" ) return False logger . trace ( \"Moving on to next block\" ) logger . debug ( \"Chain is valid\" ) return True","title":"validate_chain"},{"location":"reference/toychain/blockchain/#transaction","text":"class Transaction ( __pydantic_self__ , ** data : Any ) View Source class Transaction ( BaseModel ): sender: str recipient: str amount: float","title":"Transaction"},{"location":"reference/toychain/blockchain/#ancestors-in-mro_1","text":"pydantic.main.BaseModel pydantic.utils.Representation","title":"Ancestors (in MRO)"},{"location":"reference/toychain/blockchain/#class-variables_1","text":"Config","title":"Class variables"},{"location":"reference/toychain/blockchain/#static-methods_2","text":"","title":"Static methods"},{"location":"reference/toychain/blockchain/#construct_1","text":"def construct ( _fields_set : Optional [ ForwardRef ( 'SetStr' )] = None , ** values : Any ) -> 'Model' Creates a new model setting dict and fields_set from trusted or pre-validated data. Default values are respected, but no other validation is performed.","title":"construct"},{"location":"reference/toychain/blockchain/#from_orm_1","text":"def from_orm ( obj : Any ) -> 'Model'","title":"from_orm"},{"location":"reference/toychain/blockchain/#parse_file_1","text":"def parse_file ( path : Union [ str , pathlib . Path ], * , content_type : 'unicode' = None , encoding : 'unicode' = 'utf8' , proto : pydantic . parse . Protocol = None , allow_pickle : bool = False ) -> 'Model'","title":"parse_file"},{"location":"reference/toychain/blockchain/#parse_obj_1","text":"def parse_obj ( obj : Any ) -> 'Model'","title":"parse_obj"},{"location":"reference/toychain/blockchain/#parse_raw_1","text":"def parse_raw ( b : Union [ str , bytes ], * , content_type : 'unicode' = None , encoding : 'unicode' = 'utf8' , proto : pydantic . parse . Protocol = None , allow_pickle : bool = False ) -> 'Model'","title":"parse_raw"},{"location":"reference/toychain/blockchain/#schema_1","text":"def schema ( by_alias : bool = True , ref_template : 'unicode' = '#/definitions/ {model} ' ) -> 'DictStrAny'","title":"schema"},{"location":"reference/toychain/blockchain/#schema_json_1","text":"def schema_json ( * , by_alias : bool = True , ref_template : 'unicode' = '#/definitions/ {model} ' , ** dumps_kwargs : Any ) -> 'unicode'","title":"schema_json"},{"location":"reference/toychain/blockchain/#update_forward_refs_1","text":"def update_forward_refs ( ** localns : Any ) -> None Try to update ForwardRefs on fields based on this Model, globalns and localns.","title":"update_forward_refs"},{"location":"reference/toychain/blockchain/#validate_1","text":"def validate ( value : Any ) -> 'Model'","title":"validate"},{"location":"reference/toychain/blockchain/#instance-variables_2","text":"fields","title":"Instance variables"},{"location":"reference/toychain/blockchain/#methods_2","text":"","title":"Methods"},{"location":"reference/toychain/blockchain/#copy_1","text":"def copy ( self : 'Model' , * , include : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' )] = None , exclude : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' )] = None , update : 'DictStrAny' = None , deep : bool = False ) -> 'Model' Duplicate a model, optionally choose which fields to include, exclude and change. :param include: fields to include in new model :param exclude: fields to exclude from new model, as with values this takes precedence over include :param update: values to change/add in the new model. Note: the data is not validated before creating the new model: you should trust this data :param deep: set to True to make a deep copy of the model :return: new model instance","title":"copy"},{"location":"reference/toychain/blockchain/#dict_1","text":"def dict ( self , * , include : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' )] = None , exclude : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' )] = None , by_alias : bool = False , skip_defaults : bool = None , exclude_unset : bool = False , exclude_defaults : bool = False , exclude_none : bool = False ) -> 'DictStrAny' Generate a dictionary representation of the model, optionally specifying which fields to include or exclude.","title":"dict"},{"location":"reference/toychain/blockchain/#json_1","text":"def json ( self , * , include : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' )] = None , exclude : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' )] = None , by_alias : bool = False , skip_defaults : bool = None , exclude_unset : bool = False , exclude_defaults : bool = False , exclude_none : bool = False , encoder : Optional [ Callable [[ Any ], Any ]] = None , ** dumps_kwargs : Any ) -> 'unicode' Generate a JSON representation of the model, include and exclude arguments as per dict() . encoder is an optional function to supply as default to json.dumps(), other arguments as per json.dumps() .","title":"json"},{"location":"reference/toychain/blockchain/#to_string_1","text":"def to_string ( self , pretty : bool = False ) -> 'unicode'","title":"to_string"},{"location":"reference/toychain/node/","text":"Module toychain.node Node runner for Blockchain, to interact with using HTTP requests. View Source \"\"\" Node runner for Blockchain, to interact with using HTTP requests. \"\"\" import argparse from typing import List from uuid import uuid4 import uvicorn from fastapi import FastAPI from loguru import logger from pydantic import BaseModel from toychain.blockchain import Block , BlockChain , Transaction logger . info ( \"Instantiating node\" ) node = FastAPI () logger . info ( \"Generating globally unique address for this node\" ) NODE_IDENTIFIER = str ( uuid4 ()) . replace ( \"-\" , \"\" ) logger . info ( f \"This is node ID {NODE_IDENTIFIER}\" ) logger . info ( \"Instantiating Blockchain for this node\" ) blockchain = BlockChain () logger . success ( \"Blockchain up and running!\" ) class ActiveNode ( BaseModel ): nodes : List [ str ] @node.get ( \"/\" ) def root (): \"\"\" Greet the user and direct to the docs, that will detail the available endpoints. Returns: A JSON response. \"\"\" return { \"message\" : \"This is a running node. To get a documentation overview of the available \" \"endpoints and their functionality, head over to the '/docs' endpoint (Swagger\" \"UI style), or the '/redoc' endpoint (ReDoc style).\" } @node.get ( \"/mine\" ) def mine_block (): \"\"\" Mining endpoint. GETing `/mine` triggers the following actions:\\n - Calculating the Proof of Work.\\n - Rewarding the miner (this node) by adding a transaction granting 1 coin.\\n - Forging the new Block by adding it to the chain.\\n Returns: A JSON response. \"\"\" logger . info ( \"Received GET request to add a block\" ) logger . debug ( \"Mining proof for a new block\" ) last_block : Block = blockchain . last_block last_proof : int = last_block . proof mined_proof : int = blockchain . proof_of_work ( last_proof ) # We must receive a reward for finding the proof. # The sender is \"0\" to signify that this node has mined a new coin. logger . debug ( \"Adding block reward transaction for mining this block\" ) blockchain . add_transaction ( sender = \"0\" , recipient = NODE_IDENTIFIER , amount = 1 , ) logger . debug ( \"Forging new block and adding it to the chain\" ) previous_hash : str = blockchain . hash ( last_block ) block : Block = blockchain . add_block ( previous_hash = previous_hash , proof = mined_proof ) return { \"message\" : \"New Block Forged\" , \"index\" : block . index , \"transactions\" : block . transactions , \"proof\" : block . proof , \"previous_hash\" : block . previous_hash , } @node.post ( \"/transactions/new\" ) def new_transaction ( posted_transaction : Transaction ): \"\"\" Receives transaction data from a POST request and add it to the node's blockchain. Returns: A JSON response. \"\"\" logger . info ( \"Received POST request for new transaction\" ) transaction_block_index : int = blockchain . add_transaction ( sender = posted_transaction . sender , recipient = posted_transaction . recipient , amount = posted_transaction . amount , ) return { \"message\" : \"Transaction added to the list of current transactions and will be mined into \" f \"the block at index {transaction_block_index}\" } @node.post ( \"/nodes/register\" ) def register_nodes ( posted_transaction : ActiveNode ): \"\"\" Receives new nodes' location from a POST request and register those to this node's network. Returns: A JSON response. \"\"\" logger . info ( \"Received POST request for new nodes registration\" ) for new_node in posted_transaction . nodes : logger . debug ( f \"Attempting registration of new node `{new_node}` to the network\" ) blockchain . register_node ( address = new_node ) return { \"message\" : f \"{len(posted_transaction.nodes)} new node(s) have been successfully added\" , \"total_nodes\" : list ( blockchain . nodes ), } @node.get ( \"/nodes/resolve\" ) def consensus (): \"\"\" Run consensus algorithm to resolve conflicts, sends back status (local node's chain changed, or not). Returns: A JSON response. \"\"\" logger . info ( \"Received a GET request to resolve conflicts\" ) is_replaced = blockchain . resolve_conflicts () if is_replaced : response = { \"message\" : \"Our chain was replaced\" , \"new_chain\" : blockchain . chain } else : response = { \"message\" : \"Our chain is authoritative\" , \"chain\" : blockchain . chain } return response @node.get ( \"/chain\" ) def full_chain (): \"\"\" GETing `/chain` will returns the full blockchain. Returns: The node's full blockchain list, as a JSON response. \"\"\" logger . info ( \"Received GET request for the full chain\" ) return { \"chain\" : blockchain . chain , \"length\" : len ( blockchain . chain ), } def _parse_arguments (): \"\"\"Simply parse the port on which to run.\"\"\" parser = argparse . ArgumentParser () parser . add_argument ( \"-p\" , \"--port\" , dest = \"port\" , default = 5000 , type = int , help = \"The port on which to run a node. Defaults to 5000.\" , ) parser . add_argument ( \"--host\" , dest = \"host\" , default = \"127.0.0.1\" , type = str , help = \"The host on which to run the node. Defaults to '127.0.0.1', known as 'localhost'.\" , ) return parser . parse_args () @logger.catch def run_node (): \"\"\"Runs the node\"\"\" commandline_arguments = _parse_arguments () uvicorn . run ( node , host = commandline_arguments . host , port = commandline_arguments . port ) if __name__ == \"__main__\" : run_node () Variables NODE_IDENTIFIER blockchain node Functions consensus def consensus ( ) Run consensus algorithm to resolve conflicts, sends back status (local node's chain changed, or not). Returns: A JSON response. View Source @node . get ( \"/nodes/resolve\" ) def consensus () : \"\"\" Run consensus algorithm to resolve conflicts, sends back status (local node's chain changed, or not). Returns: A JSON response. \"\"\" logger . info ( \"Received a GET request to resolve conflicts\" ) is_replaced = blockchain . resolve_conflicts () if is_replaced : response = { \"message\" : \"Our chain was replaced\" , \"new_chain\" : blockchain . chain } else : response = { \"message\" : \"Our chain is authoritative\" , \"chain\" : blockchain . chain } return response full_chain def full_chain ( ) GETing /chain will returns the full blockchain. Returns: The node's full blockchain list, as a JSON response. View Source @node . get ( \"/chain\" ) def full_chain () : \"\"\" GETing `/chain` will returns the full blockchain. Returns: The node's full blockchain list, as a JSON response. \"\"\" logger . info ( \"Received GET request for the full chain\" ) return { \"chain\" : blockchain . chain , \"length\" : len ( blockchain . chain ), } mine_block def mine_block ( ) Mining endpoint. GETing /mine triggers the following actions: - Calculating the Proof of Work . - Rewarding the miner ( this node ) by adding a transaction granting 1 coin . - Forging the new Block by adding it to the chain . Returns: A JSON response. View Source @node . get ( \"/mine\" ) def mine_block () : \"\"\" Mining endpoint. GETing `/mine` triggers the following actions:\\n - Calculating the Proof of Work.\\n - Rewarding the miner (this node) by adding a transaction granting 1 coin.\\n - Forging the new Block by adding it to the chain.\\n Returns: A JSON response. \"\"\" logger . info ( \"Received GET request to add a block\" ) logger . debug ( \"Mining proof for a new block\" ) last_block : Block = blockchain . last_block last_proof : int = last_block . proof mined_proof : int = blockchain . proof_of_work ( last_proof ) # We must receive a reward for finding the proof . # The sender is \"0\" to signify that this node has mined a new coin . logger . debug ( \"Adding block reward transaction for mining this block\" ) blockchain . add_transaction ( sender = \"0\" , recipient = NODE_IDENTIFIER , amount = 1 , ) logger . debug ( \"Forging new block and adding it to the chain\" ) previous_hash : str = blockchain . hash ( last_block ) block : Block = blockchain . add_block ( previous_hash = previous_hash , proof = mined_proof ) return { \"message\" : \"New Block Forged\" , \"index\" : block . index , \"transactions\" : block . transactions , \"proof\" : block . proof , \"previous_hash\" : block . previous_hash , } new_transaction def new_transaction ( posted_transaction : toychain . blockchain . Transaction ) Receives transaction data from a POST request and add it to the node's blockchain. Returns: A JSON response. View Source @node . post ( \"/transactions/new\" ) def new_transaction ( posted_transaction : Transaction ) : \"\"\" Receives transaction data from a POST request and add it to the node's blockchain. Returns: A JSON response. \"\"\" logger . info ( \"Received POST request for new transaction\" ) transaction_block_index : int = blockchain . add_transaction ( sender = posted_transaction . sender , recipient = posted_transaction . recipient , amount = posted_transaction . amount , ) return { \"message\" : \"Transaction added to the list of current transactions and will be mined into \" f \"the block at index {transaction_block_index}\" } register_nodes def register_nodes ( posted_transaction : toychain . node . ActiveNode ) Receives new nodes' location from a POST request and register those to this node's network. Returns: A JSON response. View Source @node . post ( \"/nodes/register\" ) def register_nodes ( posted_transaction : ActiveNode ) : \"\"\" Receives new nodes' location from a POST request and register those to this node's network. Returns: A JSON response. \"\"\" logger . info ( \"Received POST request for new nodes registration\" ) for new_node in posted_transaction . nodes : logger . debug ( f \"Attempting registration of new node `{new_node}` to the network\" ) blockchain . register_node ( address = new_node ) return { \"message\" : f \"{len(posted_transaction.nodes)} new node(s) have been successfully added\" , \"total_nodes\" : list ( blockchain . nodes ), } root def root ( ) Greet the user and direct to the docs, that will detail the available endpoints. Returns: A JSON response. View Source @node . get ( \"/\" ) def root () : \"\"\" Greet the user and direct to the docs, that will detail the available endpoints. Returns: A JSON response. \"\"\" return { \"message\" : \"This is a running node. To get a documentation overview of the available \" \"endpoints and their functionality, head over to the '/docs' endpoint (Swagger\" \"UI style), or the '/redoc' endpoint (ReDoc style).\" } run_node def run_node ( ) Runs the node View Source @logger . catch def run_node () : \"\"\"Runs the node\"\"\" commandline_arguments = _parse_arguments () uvicorn . run ( node , host = commandline_arguments . host , port = commandline_arguments . port ) Classes ActiveNode class ActiveNode ( __pydantic_self__ , ** data : Any ) View Source class ActiveNode ( BaseModel ) : nodes : List [ str ] Ancestors (in MRO) pydantic.main.BaseModel pydantic.utils.Representation Class variables Config Static methods construct def construct ( _fields_set : Optional [ ForwardRef ( 'SetStr' )] = None , ** values : Any ) -> 'Model' Creates a new model setting dict and fields_set from trusted or pre-validated data. Default values are respected, but no other validation is performed. from_orm def from_orm ( obj : Any ) -> 'Model' parse_file def parse_file ( path : Union [ str , pathlib . Path ], * , content_type : 'unicode' = None , encoding : 'unicode' = 'utf8' , proto : pydantic . parse . Protocol = None , allow_pickle : bool = False ) -> 'Model' parse_obj def parse_obj ( obj : Any ) -> 'Model' parse_raw def parse_raw ( b : Union [ str , bytes ], * , content_type : 'unicode' = None , encoding : 'unicode' = 'utf8' , proto : pydantic . parse . Protocol = None , allow_pickle : bool = False ) -> 'Model' schema def schema ( by_alias : bool = True , ref_template : 'unicode' = '#/definitions/ {model} ' ) -> 'DictStrAny' schema_json def schema_json ( * , by_alias : bool = True , ref_template : 'unicode' = '#/definitions/ {model} ' , ** dumps_kwargs : Any ) -> 'unicode' update_forward_refs def update_forward_refs ( ** localns : Any ) -> None Try to update ForwardRefs on fields based on this Model, globalns and localns. validate def validate ( value : Any ) -> 'Model' Instance variables fields Methods copy def copy ( self : 'Model' , * , include : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' )] = None , exclude : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' )] = None , update : 'DictStrAny' = None , deep : bool = False ) -> 'Model' Duplicate a model, optionally choose which fields to include, exclude and change. :param include: fields to include in new model :param exclude: fields to exclude from new model, as with values this takes precedence over include :param update: values to change/add in the new model. Note: the data is not validated before creating the new model: you should trust this data :param deep: set to True to make a deep copy of the model :return: new model instance dict def dict ( self , * , include : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' )] = None , exclude : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' )] = None , by_alias : bool = False , skip_defaults : bool = None , exclude_unset : bool = False , exclude_defaults : bool = False , exclude_none : bool = False ) -> 'DictStrAny' Generate a dictionary representation of the model, optionally specifying which fields to include or exclude. json def json ( self , * , include : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' )] = None , exclude : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' )] = None , by_alias : bool = False , skip_defaults : bool = None , exclude_unset : bool = False , exclude_defaults : bool = False , exclude_none : bool = False , encoder : Optional [ Callable [[ Any ], Any ]] = None , ** dumps_kwargs : Any ) -> 'unicode' Generate a JSON representation of the model, include and exclude arguments as per dict() . encoder is an optional function to supply as default to json.dumps(), other arguments as per json.dumps() . to_string def to_string ( self , pretty : bool = False ) -> 'unicode'","title":"Node"},{"location":"reference/toychain/node/#module-toychainnode","text":"Node runner for Blockchain, to interact with using HTTP requests. View Source \"\"\" Node runner for Blockchain, to interact with using HTTP requests. \"\"\" import argparse from typing import List from uuid import uuid4 import uvicorn from fastapi import FastAPI from loguru import logger from pydantic import BaseModel from toychain.blockchain import Block , BlockChain , Transaction logger . info ( \"Instantiating node\" ) node = FastAPI () logger . info ( \"Generating globally unique address for this node\" ) NODE_IDENTIFIER = str ( uuid4 ()) . replace ( \"-\" , \"\" ) logger . info ( f \"This is node ID {NODE_IDENTIFIER}\" ) logger . info ( \"Instantiating Blockchain for this node\" ) blockchain = BlockChain () logger . success ( \"Blockchain up and running!\" ) class ActiveNode ( BaseModel ): nodes : List [ str ] @node.get ( \"/\" ) def root (): \"\"\" Greet the user and direct to the docs, that will detail the available endpoints. Returns: A JSON response. \"\"\" return { \"message\" : \"This is a running node. To get a documentation overview of the available \" \"endpoints and their functionality, head over to the '/docs' endpoint (Swagger\" \"UI style), or the '/redoc' endpoint (ReDoc style).\" } @node.get ( \"/mine\" ) def mine_block (): \"\"\" Mining endpoint. GETing `/mine` triggers the following actions:\\n - Calculating the Proof of Work.\\n - Rewarding the miner (this node) by adding a transaction granting 1 coin.\\n - Forging the new Block by adding it to the chain.\\n Returns: A JSON response. \"\"\" logger . info ( \"Received GET request to add a block\" ) logger . debug ( \"Mining proof for a new block\" ) last_block : Block = blockchain . last_block last_proof : int = last_block . proof mined_proof : int = blockchain . proof_of_work ( last_proof ) # We must receive a reward for finding the proof. # The sender is \"0\" to signify that this node has mined a new coin. logger . debug ( \"Adding block reward transaction for mining this block\" ) blockchain . add_transaction ( sender = \"0\" , recipient = NODE_IDENTIFIER , amount = 1 , ) logger . debug ( \"Forging new block and adding it to the chain\" ) previous_hash : str = blockchain . hash ( last_block ) block : Block = blockchain . add_block ( previous_hash = previous_hash , proof = mined_proof ) return { \"message\" : \"New Block Forged\" , \"index\" : block . index , \"transactions\" : block . transactions , \"proof\" : block . proof , \"previous_hash\" : block . previous_hash , } @node.post ( \"/transactions/new\" ) def new_transaction ( posted_transaction : Transaction ): \"\"\" Receives transaction data from a POST request and add it to the node's blockchain. Returns: A JSON response. \"\"\" logger . info ( \"Received POST request for new transaction\" ) transaction_block_index : int = blockchain . add_transaction ( sender = posted_transaction . sender , recipient = posted_transaction . recipient , amount = posted_transaction . amount , ) return { \"message\" : \"Transaction added to the list of current transactions and will be mined into \" f \"the block at index {transaction_block_index}\" } @node.post ( \"/nodes/register\" ) def register_nodes ( posted_transaction : ActiveNode ): \"\"\" Receives new nodes' location from a POST request and register those to this node's network. Returns: A JSON response. \"\"\" logger . info ( \"Received POST request for new nodes registration\" ) for new_node in posted_transaction . nodes : logger . debug ( f \"Attempting registration of new node `{new_node}` to the network\" ) blockchain . register_node ( address = new_node ) return { \"message\" : f \"{len(posted_transaction.nodes)} new node(s) have been successfully added\" , \"total_nodes\" : list ( blockchain . nodes ), } @node.get ( \"/nodes/resolve\" ) def consensus (): \"\"\" Run consensus algorithm to resolve conflicts, sends back status (local node's chain changed, or not). Returns: A JSON response. \"\"\" logger . info ( \"Received a GET request to resolve conflicts\" ) is_replaced = blockchain . resolve_conflicts () if is_replaced : response = { \"message\" : \"Our chain was replaced\" , \"new_chain\" : blockchain . chain } else : response = { \"message\" : \"Our chain is authoritative\" , \"chain\" : blockchain . chain } return response @node.get ( \"/chain\" ) def full_chain (): \"\"\" GETing `/chain` will returns the full blockchain. Returns: The node's full blockchain list, as a JSON response. \"\"\" logger . info ( \"Received GET request for the full chain\" ) return { \"chain\" : blockchain . chain , \"length\" : len ( blockchain . chain ), } def _parse_arguments (): \"\"\"Simply parse the port on which to run.\"\"\" parser = argparse . ArgumentParser () parser . add_argument ( \"-p\" , \"--port\" , dest = \"port\" , default = 5000 , type = int , help = \"The port on which to run a node. Defaults to 5000.\" , ) parser . add_argument ( \"--host\" , dest = \"host\" , default = \"127.0.0.1\" , type = str , help = \"The host on which to run the node. Defaults to '127.0.0.1', known as 'localhost'.\" , ) return parser . parse_args () @logger.catch def run_node (): \"\"\"Runs the node\"\"\" commandline_arguments = _parse_arguments () uvicorn . run ( node , host = commandline_arguments . host , port = commandline_arguments . port ) if __name__ == \"__main__\" : run_node ()","title":"Module toychain.node"},{"location":"reference/toychain/node/#variables","text":"NODE_IDENTIFIER blockchain node","title":"Variables"},{"location":"reference/toychain/node/#functions","text":"","title":"Functions"},{"location":"reference/toychain/node/#consensus","text":"def consensus ( ) Run consensus algorithm to resolve conflicts, sends back status (local node's chain changed, or not). Returns: A JSON response. View Source @node . get ( \"/nodes/resolve\" ) def consensus () : \"\"\" Run consensus algorithm to resolve conflicts, sends back status (local node's chain changed, or not). Returns: A JSON response. \"\"\" logger . info ( \"Received a GET request to resolve conflicts\" ) is_replaced = blockchain . resolve_conflicts () if is_replaced : response = { \"message\" : \"Our chain was replaced\" , \"new_chain\" : blockchain . chain } else : response = { \"message\" : \"Our chain is authoritative\" , \"chain\" : blockchain . chain } return response","title":"consensus"},{"location":"reference/toychain/node/#full_chain","text":"def full_chain ( ) GETing /chain will returns the full blockchain. Returns: The node's full blockchain list, as a JSON response. View Source @node . get ( \"/chain\" ) def full_chain () : \"\"\" GETing `/chain` will returns the full blockchain. Returns: The node's full blockchain list, as a JSON response. \"\"\" logger . info ( \"Received GET request for the full chain\" ) return { \"chain\" : blockchain . chain , \"length\" : len ( blockchain . chain ), }","title":"full_chain"},{"location":"reference/toychain/node/#mine_block","text":"def mine_block ( ) Mining endpoint. GETing /mine triggers the following actions: - Calculating the Proof of Work . - Rewarding the miner ( this node ) by adding a transaction granting 1 coin . - Forging the new Block by adding it to the chain . Returns: A JSON response. View Source @node . get ( \"/mine\" ) def mine_block () : \"\"\" Mining endpoint. GETing `/mine` triggers the following actions:\\n - Calculating the Proof of Work.\\n - Rewarding the miner (this node) by adding a transaction granting 1 coin.\\n - Forging the new Block by adding it to the chain.\\n Returns: A JSON response. \"\"\" logger . info ( \"Received GET request to add a block\" ) logger . debug ( \"Mining proof for a new block\" ) last_block : Block = blockchain . last_block last_proof : int = last_block . proof mined_proof : int = blockchain . proof_of_work ( last_proof ) # We must receive a reward for finding the proof . # The sender is \"0\" to signify that this node has mined a new coin . logger . debug ( \"Adding block reward transaction for mining this block\" ) blockchain . add_transaction ( sender = \"0\" , recipient = NODE_IDENTIFIER , amount = 1 , ) logger . debug ( \"Forging new block and adding it to the chain\" ) previous_hash : str = blockchain . hash ( last_block ) block : Block = blockchain . add_block ( previous_hash = previous_hash , proof = mined_proof ) return { \"message\" : \"New Block Forged\" , \"index\" : block . index , \"transactions\" : block . transactions , \"proof\" : block . proof , \"previous_hash\" : block . previous_hash , }","title":"mine_block"},{"location":"reference/toychain/node/#new_transaction","text":"def new_transaction ( posted_transaction : toychain . blockchain . Transaction ) Receives transaction data from a POST request and add it to the node's blockchain. Returns: A JSON response. View Source @node . post ( \"/transactions/new\" ) def new_transaction ( posted_transaction : Transaction ) : \"\"\" Receives transaction data from a POST request and add it to the node's blockchain. Returns: A JSON response. \"\"\" logger . info ( \"Received POST request for new transaction\" ) transaction_block_index : int = blockchain . add_transaction ( sender = posted_transaction . sender , recipient = posted_transaction . recipient , amount = posted_transaction . amount , ) return { \"message\" : \"Transaction added to the list of current transactions and will be mined into \" f \"the block at index {transaction_block_index}\" }","title":"new_transaction"},{"location":"reference/toychain/node/#register_nodes","text":"def register_nodes ( posted_transaction : toychain . node . ActiveNode ) Receives new nodes' location from a POST request and register those to this node's network. Returns: A JSON response. View Source @node . post ( \"/nodes/register\" ) def register_nodes ( posted_transaction : ActiveNode ) : \"\"\" Receives new nodes' location from a POST request and register those to this node's network. Returns: A JSON response. \"\"\" logger . info ( \"Received POST request for new nodes registration\" ) for new_node in posted_transaction . nodes : logger . debug ( f \"Attempting registration of new node `{new_node}` to the network\" ) blockchain . register_node ( address = new_node ) return { \"message\" : f \"{len(posted_transaction.nodes)} new node(s) have been successfully added\" , \"total_nodes\" : list ( blockchain . nodes ), }","title":"register_nodes"},{"location":"reference/toychain/node/#root","text":"def root ( ) Greet the user and direct to the docs, that will detail the available endpoints. Returns: A JSON response. View Source @node . get ( \"/\" ) def root () : \"\"\" Greet the user and direct to the docs, that will detail the available endpoints. Returns: A JSON response. \"\"\" return { \"message\" : \"This is a running node. To get a documentation overview of the available \" \"endpoints and their functionality, head over to the '/docs' endpoint (Swagger\" \"UI style), or the '/redoc' endpoint (ReDoc style).\" }","title":"root"},{"location":"reference/toychain/node/#run_node","text":"def run_node ( ) Runs the node View Source @logger . catch def run_node () : \"\"\"Runs the node\"\"\" commandline_arguments = _parse_arguments () uvicorn . run ( node , host = commandline_arguments . host , port = commandline_arguments . port )","title":"run_node"},{"location":"reference/toychain/node/#classes","text":"","title":"Classes"},{"location":"reference/toychain/node/#activenode","text":"class ActiveNode ( __pydantic_self__ , ** data : Any ) View Source class ActiveNode ( BaseModel ) : nodes : List [ str ]","title":"ActiveNode"},{"location":"reference/toychain/node/#ancestors-in-mro","text":"pydantic.main.BaseModel pydantic.utils.Representation","title":"Ancestors (in MRO)"},{"location":"reference/toychain/node/#class-variables","text":"Config","title":"Class variables"},{"location":"reference/toychain/node/#static-methods","text":"","title":"Static methods"},{"location":"reference/toychain/node/#construct","text":"def construct ( _fields_set : Optional [ ForwardRef ( 'SetStr' )] = None , ** values : Any ) -> 'Model' Creates a new model setting dict and fields_set from trusted or pre-validated data. Default values are respected, but no other validation is performed.","title":"construct"},{"location":"reference/toychain/node/#from_orm","text":"def from_orm ( obj : Any ) -> 'Model'","title":"from_orm"},{"location":"reference/toychain/node/#parse_file","text":"def parse_file ( path : Union [ str , pathlib . Path ], * , content_type : 'unicode' = None , encoding : 'unicode' = 'utf8' , proto : pydantic . parse . Protocol = None , allow_pickle : bool = False ) -> 'Model'","title":"parse_file"},{"location":"reference/toychain/node/#parse_obj","text":"def parse_obj ( obj : Any ) -> 'Model'","title":"parse_obj"},{"location":"reference/toychain/node/#parse_raw","text":"def parse_raw ( b : Union [ str , bytes ], * , content_type : 'unicode' = None , encoding : 'unicode' = 'utf8' , proto : pydantic . parse . Protocol = None , allow_pickle : bool = False ) -> 'Model'","title":"parse_raw"},{"location":"reference/toychain/node/#schema","text":"def schema ( by_alias : bool = True , ref_template : 'unicode' = '#/definitions/ {model} ' ) -> 'DictStrAny'","title":"schema"},{"location":"reference/toychain/node/#schema_json","text":"def schema_json ( * , by_alias : bool = True , ref_template : 'unicode' = '#/definitions/ {model} ' , ** dumps_kwargs : Any ) -> 'unicode'","title":"schema_json"},{"location":"reference/toychain/node/#update_forward_refs","text":"def update_forward_refs ( ** localns : Any ) -> None Try to update ForwardRefs on fields based on this Model, globalns and localns.","title":"update_forward_refs"},{"location":"reference/toychain/node/#validate","text":"def validate ( value : Any ) -> 'Model'","title":"validate"},{"location":"reference/toychain/node/#instance-variables","text":"fields","title":"Instance variables"},{"location":"reference/toychain/node/#methods","text":"","title":"Methods"},{"location":"reference/toychain/node/#copy","text":"def copy ( self : 'Model' , * , include : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' )] = None , exclude : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' )] = None , update : 'DictStrAny' = None , deep : bool = False ) -> 'Model' Duplicate a model, optionally choose which fields to include, exclude and change. :param include: fields to include in new model :param exclude: fields to exclude from new model, as with values this takes precedence over include :param update: values to change/add in the new model. Note: the data is not validated before creating the new model: you should trust this data :param deep: set to True to make a deep copy of the model :return: new model instance","title":"copy"},{"location":"reference/toychain/node/#dict","text":"def dict ( self , * , include : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' )] = None , exclude : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' )] = None , by_alias : bool = False , skip_defaults : bool = None , exclude_unset : bool = False , exclude_defaults : bool = False , exclude_none : bool = False ) -> 'DictStrAny' Generate a dictionary representation of the model, optionally specifying which fields to include or exclude.","title":"dict"},{"location":"reference/toychain/node/#json","text":"def json ( self , * , include : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' )] = None , exclude : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' )] = None , by_alias : bool = False , skip_defaults : bool = None , exclude_unset : bool = False , exclude_defaults : bool = False , exclude_none : bool = False , encoder : Optional [ Callable [[ Any ], Any ]] = None , ** dumps_kwargs : Any ) -> 'unicode' Generate a JSON representation of the model, include and exclude arguments as per dict() . encoder is an optional function to supply as default to json.dumps(), other arguments as per json.dumps() .","title":"json"},{"location":"reference/toychain/node/#to_string","text":"def to_string ( self , pretty : bool = False ) -> 'unicode'","title":"to_string"}]}