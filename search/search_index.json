{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"toychain toychain is a very simplistic blockchain node modeling in Python. While the code is my own adaptation, the implementation and architecture is from the very good tutorial by Daniel van Flymen. This adaptation uses FastAPI as a web framework, and uvicorn as ASGI server instead of the Flask app from van Flymen's tutorial. Link to documentation . License Copyright \u00a9 2020 Felix Soubelet. MIT License","title":"Home"},{"location":"#license","text":"Copyright \u00a9 2020 Felix Soubelet. MIT License","title":"License"},{"location":"docs/Getting_Started/","text":"Getting Started Installation There are two possible methods for installing and running toychain: either as a Python package with pip , or as a Docker image. With pip You can now install this simply in a virtual environment with: pip install toychain Installation in a virtual environment Don't know what a virtual environment is or how to set it up? Here is a good primer on virtual environments by RealPython. How about a development environment? Sure thing. This repository uses Poetry as a packaging and build tool. To set yourself up, get a local copy through VCS and run: poetry install You're now good to go, code away! To test your changes to the code, you can start up a node at localhost:5000 with the predefined command: poetry run node Building documentation Here's a necessary tweak. As of right now the Portray package, which is used to build the documentation, specifies requirements for mkdocs-material and pymdown-extensions to be respectively in versions 4 and 6. However, this project's documentation makes use of features from mkdocs-material >= 5.2 and pymdown-extensions >= 7.0 . The workaround to get those working is to build and install Portray locally with compatibility for these higher versions. You can do so by modifying the requirements in Portray's pyproject.toml file, specifying: mkdocs-material = \"^5.0\" pymdown-extensions = \"^7.0\" . You can then build wheels for this version with poetry publish . The final step is to pip install the built wheel into toychain's virtual environment. You can then use Portray to build documentation. With Docker It is possible to run nodes as Docker containers. For now, there is no existing image you can pull from Docker Hub, so you will have to build it localy. To do so, clone the repository and build the image with: docker build -t blockchain . Running As a Python Package The usage is simple and goes as: python -m toychain Command Line Options You can specify the port as well as the host on which to run the node with the --port and --host flags, which allows you to easily spin up several nodes. The usage goes as: usage: __main__.py [ -h ] [ -p PORT ] [ --host HOST ] optional arguments: -h, --help show this help message and exit -p PORT, --port PORT The port on which to run a node. Defaults to 5000 . --host HOST The host on which to run the node. Defaults to '127.0.0.1' , known as 'localhost' . As a Docker Container Assuming you have built the image as instructed above, you can then run a container by mapping the node's port to a desired one at localhost on your machine. To map the node to port 5000, run: docker run --init --rm -p 5000 :5000 blockchain To emulate additional nodes, vary the public port number: docker run --init --rm -p 5001 :5000 blockchain docker run --init --rm -p 5002 :5000 blockchain docker run --init --rm -p 5003 :5000 blockchain You can then play around by POSTing to /nodes/register to add all your running instances to one another's networks, POSTing transactions, mining new blocks, and resolving the blockchain. Refer to the Functionality section of this documentation for more information.","title":"Getting Started"},{"location":"docs/Getting_Started/#getting-started","text":"","title":"Getting Started"},{"location":"docs/Getting_Started/#installation","text":"There are two possible methods for installing and running toychain: either as a Python package with pip , or as a Docker image.","title":"Installation"},{"location":"docs/Getting_Started/#with-pip","text":"You can now install this simply in a virtual environment with: pip install toychain Installation in a virtual environment Don't know what a virtual environment is or how to set it up? Here is a good primer on virtual environments by RealPython. How about a development environment? Sure thing. This repository uses Poetry as a packaging and build tool. To set yourself up, get a local copy through VCS and run: poetry install You're now good to go, code away! To test your changes to the code, you can start up a node at localhost:5000 with the predefined command: poetry run node Building documentation Here's a necessary tweak. As of right now the Portray package, which is used to build the documentation, specifies requirements for mkdocs-material and pymdown-extensions to be respectively in versions 4 and 6. However, this project's documentation makes use of features from mkdocs-material >= 5.2 and pymdown-extensions >= 7.0 . The workaround to get those working is to build and install Portray locally with compatibility for these higher versions. You can do so by modifying the requirements in Portray's pyproject.toml file, specifying: mkdocs-material = \"^5.0\" pymdown-extensions = \"^7.0\" . You can then build wheels for this version with poetry publish . The final step is to pip install the built wheel into toychain's virtual environment. You can then use Portray to build documentation.","title":"With pip"},{"location":"docs/Getting_Started/#with-docker","text":"It is possible to run nodes as Docker containers. For now, there is no existing image you can pull from Docker Hub, so you will have to build it localy. To do so, clone the repository and build the image with: docker build -t blockchain .","title":"With Docker"},{"location":"docs/Getting_Started/#running","text":"","title":"Running"},{"location":"docs/Getting_Started/#as-a-python-package","text":"The usage is simple and goes as: python -m toychain Command Line Options You can specify the port as well as the host on which to run the node with the --port and --host flags, which allows you to easily spin up several nodes. The usage goes as: usage: __main__.py [ -h ] [ -p PORT ] [ --host HOST ] optional arguments: -h, --help show this help message and exit -p PORT, --port PORT The port on which to run a node. Defaults to 5000 . --host HOST The host on which to run the node. Defaults to '127.0.0.1' , known as 'localhost' .","title":"As a Python Package"},{"location":"docs/Getting_Started/#as-a-docker-container","text":"Assuming you have built the image as instructed above, you can then run a container by mapping the node's port to a desired one at localhost on your machine. To map the node to port 5000, run: docker run --init --rm -p 5000 :5000 blockchain To emulate additional nodes, vary the public port number: docker run --init --rm -p 5001 :5000 blockchain docker run --init --rm -p 5002 :5000 blockchain docker run --init --rm -p 5003 :5000 blockchain You can then play around by POSTing to /nodes/register to add all your running instances to one another's networks, POSTing transactions, mining new blocks, and resolving the blockchain. Refer to the Functionality section of this documentation for more information.","title":"As a Docker Container"},{"location":"docs/Functionality/Blockchain/","text":"The Blockchain Implementation The blockchain functionality is provided by a single class, BlockChain , in the toychain.blockchain module. It is a simple list of blocks, each block in the chain consisting of a dictionnary with the following keys: the index at which it is located in the chain, a timestamp of when the block was added to the chain, the list of transactions recorded in the block, the proof of validity for itself, a previous_hash tag referencing the hash of the previous block in the chain, for immutability. What's in the Blockchain? The json payload for an example block with a single transaction would look like this: block = { \"index\" : 1 , \"timestamp\" : 1506057125.900785 , \"transactions\" : [ { \"sender\" : \"8527147fe1f5426f9dd545de4b27ee00\" , \"recipient\" : \"a77f5cdfa2934df3954a5c7c7da5df1f\" , \"amount\" : 5 , } ], \"proof\" : 324984774000 , \"previous_hash\" : \"2cf24dba5fb0a30e26e83b2ac5b9e29e1b161e5c1fa7425e73043362938b9824\" } Want to learn a bit about Blockchains? If you want to dive a bit into how cryptocurrencies and blockchains work, I recommend you watch this excellent video by 3Blue1Brown.","title":"Blockchain"},{"location":"docs/Functionality/Blockchain/#the-blockchain-implementation","text":"The blockchain functionality is provided by a single class, BlockChain , in the toychain.blockchain module. It is a simple list of blocks, each block in the chain consisting of a dictionnary with the following keys: the index at which it is located in the chain, a timestamp of when the block was added to the chain, the list of transactions recorded in the block, the proof of validity for itself, a previous_hash tag referencing the hash of the previous block in the chain, for immutability.","title":"The Blockchain Implementation"},{"location":"docs/Functionality/Blockchain/#whats-in-the-blockchain","text":"The json payload for an example block with a single transaction would look like this: block = { \"index\" : 1 , \"timestamp\" : 1506057125.900785 , \"transactions\" : [ { \"sender\" : \"8527147fe1f5426f9dd545de4b27ee00\" , \"recipient\" : \"a77f5cdfa2934df3954a5c7c7da5df1f\" , \"amount\" : 5 , } ], \"proof\" : 324984774000 , \"previous_hash\" : \"2cf24dba5fb0a30e26e83b2ac5b9e29e1b161e5c1fa7425e73043362938b9824\" } Want to learn a bit about Blockchains? If you want to dive a bit into how cryptocurrencies and blockchains work, I recommend you watch this excellent video by 3Blue1Brown.","title":"What's in the Blockchain?"},{"location":"docs/Functionality/Node/","text":"The Node Implementation A node is ran as a REST API using the FastAPI web framework, and is attributed a UUID at startup. Each node stores a full blockchain, the current transactions (to be written in the next block), and the list of other nodes registered in the network. Each node's blockchain is a BlockChain object from the toychain.blockchain module. A node can: Add a transaction to the list of current transactions, Add a new block to its chain, Run the proof of work algorithm, Validate the proof of a block, Register other nodes on the network, Infer an arbitrary node's blockchain's validity, Resolve conflict through a consensus algorithm, checking all nodes' chains in the network and adopting the longest valid one. What endpoints are available for those actions? GET endpoint /mine to trigger the addition of a new block to the chain, POST endpoint /transactions/new to add a transaction to the node's list, GET endpoint /chain to pull the full chain, POST endpoint /nodes/register to register other nodes' addresses as part of the network, GET endpoint /nodes/resolve : to trigger a run of the consensus algorithm and resolve conflicts: the longest valid chain of all nodes in the network is used as reference, replacing the local one, and is returned. How do I remember these? Once the server is running, FastAPI serves an automated documentation at the /docs and /redoc endpoints. So if your node is running at localhost:5000 , head over to localhost:5000/docs for instance. If you simply head to localhost:5000 , you'll get a hint on where to go ;) Interacting with a Node Let's consider our node is running at localhost:5000 . Here's how to POST a transaction to the node's transactions/new endpoint with either cURL , HTTPie or Wget : cURL curl --request POST \\ --url http://localhost:5000/transactions/new \\ --header 'content-type: application/json' \\ --data '{ \"sender\": \"d4ee26eee15148ee92c6cd394edd974e\", \"recipient\": \"someone-other-address\", \"amount\": 5 }' HTTPie echo '{ \"sender\": \"d4ee26eee15148ee92c6cd394edd974e\", \"recipient\": \"someone-other-address\", \"amount\": 5 }' | http POST http://localhost:5000/transactions/new Wget wget --quiet \\ --method POST \\ --header 'content-type: application/json' \\ --body-data '{\\n \"sender\": \"d4ee26eee15148ee92c6cd394edd974e\",\\n \"recipient\": \"someone-other-address\",\\n \"amount\": 5\\n}' \\ --output-document \\ - http://localhost:5000/transactions/new Let's now consider that we have started a second node at localhost:5001 . POSTing a payload to register this new node to the first one's network would be done as follows: cURL curl --request POST \\ --url http://localhost:5000/nodes/register \\ --header 'content-type: application/json' \\ --data '{ \"nodes\": [\"http://127.0.0.1:5001\"] }' HTTPie echo '{ \"nodes\": [\"http://127.0.0.1:5001\"] }' | http POST http://localhost:5000/nodes/register Wget wget --quiet \\ --method POST \\ --header 'content-type: application/json' \\ --body-data '{\\n \"nodes\": [\"http://127.0.0.1:5001\"]\\n}' \\ --output-document \\ - http://localhost:5000/nodes/register","title":"Node"},{"location":"docs/Functionality/Node/#the-node-implementation","text":"A node is ran as a REST API using the FastAPI web framework, and is attributed a UUID at startup. Each node stores a full blockchain, the current transactions (to be written in the next block), and the list of other nodes registered in the network. Each node's blockchain is a BlockChain object from the toychain.blockchain module. A node can: Add a transaction to the list of current transactions, Add a new block to its chain, Run the proof of work algorithm, Validate the proof of a block, Register other nodes on the network, Infer an arbitrary node's blockchain's validity, Resolve conflict through a consensus algorithm, checking all nodes' chains in the network and adopting the longest valid one. What endpoints are available for those actions? GET endpoint /mine to trigger the addition of a new block to the chain, POST endpoint /transactions/new to add a transaction to the node's list, GET endpoint /chain to pull the full chain, POST endpoint /nodes/register to register other nodes' addresses as part of the network, GET endpoint /nodes/resolve : to trigger a run of the consensus algorithm and resolve conflicts: the longest valid chain of all nodes in the network is used as reference, replacing the local one, and is returned. How do I remember these? Once the server is running, FastAPI serves an automated documentation at the /docs and /redoc endpoints. So if your node is running at localhost:5000 , head over to localhost:5000/docs for instance. If you simply head to localhost:5000 , you'll get a hint on where to go ;)","title":"The Node Implementation"},{"location":"docs/Functionality/Node/#interacting-with-a-node","text":"Let's consider our node is running at localhost:5000 . Here's how to POST a transaction to the node's transactions/new endpoint with either cURL , HTTPie or Wget : cURL curl --request POST \\ --url http://localhost:5000/transactions/new \\ --header 'content-type: application/json' \\ --data '{ \"sender\": \"d4ee26eee15148ee92c6cd394edd974e\", \"recipient\": \"someone-other-address\", \"amount\": 5 }' HTTPie echo '{ \"sender\": \"d4ee26eee15148ee92c6cd394edd974e\", \"recipient\": \"someone-other-address\", \"amount\": 5 }' | http POST http://localhost:5000/transactions/new Wget wget --quiet \\ --method POST \\ --header 'content-type: application/json' \\ --body-data '{\\n \"sender\": \"d4ee26eee15148ee92c6cd394edd974e\",\\n \"recipient\": \"someone-other-address\",\\n \"amount\": 5\\n}' \\ --output-document \\ - http://localhost:5000/transactions/new Let's now consider that we have started a second node at localhost:5001 . POSTing a payload to register this new node to the first one's network would be done as follows: cURL curl --request POST \\ --url http://localhost:5000/nodes/register \\ --header 'content-type: application/json' \\ --data '{ \"nodes\": [\"http://127.0.0.1:5001\"] }' HTTPie echo '{ \"nodes\": [\"http://127.0.0.1:5001\"] }' | http POST http://localhost:5000/nodes/register Wget wget --quiet \\ --method POST \\ --header 'content-type: application/json' \\ --body-data '{\\n \"nodes\": [\"http://127.0.0.1:5001\"]\\n}' \\ --output-document \\ - http://localhost:5000/nodes/register","title":"Interacting with a Node"},{"location":"reference/toychain/","text":"Module toychain Sub-modules toychain.blockchain toychain.node","title":"Index"},{"location":"reference/toychain/#module-toychain","text":"","title":"Module toychain"},{"location":"reference/toychain/#sub-modules","text":"toychain.blockchain toychain.node","title":"Sub-modules"},{"location":"reference/toychain/blockchain/","text":"Module toychain.blockchain Simple emulation of a blockchain. View Source \"\"\" Simple emulation of a blockchain. \"\"\" import hashlib import json from time import time from typing import Dict , List , Optional from urllib.parse import ParseResult , urlparse import requests from loguru import logger class BlockChain : \"\"\"Simple class to emulate a blockchain\"\"\" def __init__ ( self ): self . chain : List [ Dict ] = [] self . current_transactions : List [ Dict ] = [] self . nodes = set () logger . debug ( \"Initiating first block\" ) self . add_block ( previous_hash = 1 , proof = 100 ) def add_block ( self , previous_hash : Optional [ str ] = None , proof : int = None ) -> Dict : \"\"\" Create a new block and add it to the chain. Args: previous_hash: string (optional), hash of the previous block in the chain. proof: integer, the proof given by the proof of work algorithm. Returns: The new block as a dictionary. \"\"\" logger . debug ( \"Creating a new block\" ) block = { \"index\" : len ( self . chain ) + 1 , \"timestamp\" : time (), \"transactions\" : self . current_transactions , \"proof\" : proof , \"previous_hash\" : previous_hash or self . hash ( self . chain [ - 1 ]), } logger . debug ( \"Resetting the current list of transations\" ) self . current_transactions = [] logger . debug ( \"Adding block to the chain\" ) self . chain . append ( block ) return block def add_transaction ( self , sender : str = None , recipient : str = None , amount : float = None ) -> int : \"\"\" Adds a new transaction to the list of transactions. Args: sender: string, address of the sender. recipient: string, address of the recipient. amount: float, the amount of the transaction. Returns: An integer containing the address of the block that will hold this transaction. \"\"\" logger . debug ( \"Adding transaction to the blockchain\" ) self . current_transactions . append ( { \"sender\" : sender , \"recipient\" : recipient , \"amount\" : amount } ) return self . last_block [ \"index\" ] + 1 @property def last_block ( self ) -> Dict : \"\"\" Returns the last block in the chain. Returns: The last block in the chain, as a dictionnary object. \"\"\" return self . chain [ - 1 ] @staticmethod def hash ( block : Dict = None ) -> str : \"\"\" Hashes a new block. Args: block: dictionnary with the block's contents. Returns: The block's hash. \"\"\" logger . debug ( \"Ordering dictionary and dumping to json\" ) # ordering for consistent hashes block_string = json . dumps ( block , sort_keys = True ) . encode () logger . debug ( \"Hashing dumped block\" ) return hashlib . sha256 ( block_string ) . hexdigest () @staticmethod def validate_proof ( last_proof : int = None , new_proof : int = None ) -> bool : \"\"\" Validates a proof: does hash(last_proof, new_proof) contain 4 leading zeroes? Args: last_proof: integer, the previous proof in the chain. new_proof: integer, the new proof. Returns: True if new_proof is validated, False otherwise. \"\"\" logger . trace ( \"Checking proof validity\" ) guess = f \"{last_proof}{new_proof}\" . encode () guess_hash = hashlib . sha256 ( guess ) . hexdigest () if guess_hash [: 4 ] == \"0000\" : logger . debug ( \"Proof iteration is valid\" ) return True else : logger . trace ( \"Proof is invalid\" ) return False def proof_of_work ( self , last_proof : int = None ) -> int : \"\"\" Simple Proof of Work Algorithm: - Find a number p' such that hash(pp') has leading 4 zeroes, where p is the previous p' - p is the previous proof, and p' is the new proof Args: last_proof: integer, the previous proof in the chain. Returns: The new proof, an integer. \"\"\" proof = 0 while self . validate_proof ( last_proof , proof ) is False : logger . trace ( \"Proof didn't pass, iterating\" ) proof += 1 logger . success ( \"Successfully mined block proof\" ) return proof def register_node ( self , address : str = None ) -> None : \"\"\" Register a new node as part of the network by adding it to the list of nodes. Args: address: string, address of node to register. Eg. 'http://192.168.0.5:5000' Returns: Nothing, adds in place. \"\"\" logger . debug ( f \"Parsing new node address {address}\" ) parsed_url : ParseResult = urlparse ( address ) node_netloc : str = parsed_url . netloc if node_netloc in self . nodes : logger . warning ( f \"Node at {address} is already registered, skipping\" ) logger . debug ( \"Adding new element to network's registered nodes\" ) self . nodes . add ( node_netloc ) def validate_chain ( self , chain : List [ Dict ]) -> bool : \"\"\" Determine if a given blockchain from any arbitrary node in the network is valid. Args: chain: list, a complete blockchain (list of blocks as dicts). Returns: True if the chain is valid, False otherwise \"\"\" logger . debug ( \"Determining chain validity\" ) last_block = chain [ 0 ] for current_index in range ( 1 , len ( chain )): logger . trace ( f \"Inspecting block at index {current_index}\" ) inspected_block = chain [ current_index ] logger . trace ( \"Checking block's hash\" ) if inspected_block [ \"previous_hash\" ] != self . hash ( last_block ): logger . error ( f \"Invalid block tag 'previous_hash' \" f \"{inspected_block['previous_hash']}\" ) return False logger . trace ( \"Checking block's proof of work\" ) if not self . validate_proof ( last_proof = last_block [ \"proof\" ], new_proof = inspected_block [ \"proof\" ] ): logger . error ( f \"Invalid proof from last block's proof {last_block['proof']} and \" f \"inspected block's proof {inspected_block['proof']}\" ) return False logger . trace ( \"Moving on to next block\" ) last_block = inspected_block logger . debug ( \"Chain is valid!\" ) return True def resolve_conflicts ( self ) -> bool : \"\"\" This is the Consensus Algorithm. It resolves conflicts by replacing the node's chain with the longest valid one in the network. Returns: True if the node's chain was replaced, False otherwise \"\"\" neighbouring_nodes = self . nodes new_chain = None max_length = len ( self . chain ) # initialize with this node's length logger . debug ( \"Verifying chains from all nodes in the network\" ) for node in neighbouring_nodes : logger . debug ( \"Querying node for its full chain\" ) node_chain_response = requests . get ( f \"http://{node}/chain\" ) if node_chain_response . status_code == 200 : logger . trace ( \"Full chain received\" ) length = node_chain_response . json ()[ \"length\" ] chain = node_chain_response . json ()[ \"chain\" ] logger . trace ( \"Checking if requested chain is valid and longer than mine\" ) if length > max_length and self . validate_chain ( chain ): max_length = length new_chain = chain if new_chain : logger . info ( \"Found a valid chain longer than this node's, adopting it now\" ) self . chain = new_chain return True logger . info ( \"No valid chain was longer than this node's\" ) return False Classes BlockChain class BlockChain ( ) Simple class to emulate a blockchain View Source class BlockChain : \"\"\"Simple class to emulate a blockchain\"\"\" def __init__ ( self ) : self . chain : List [ Dict ] = [] self . current_transactions : List [ Dict ] = [] self . nodes = set () logger . debug ( \"Initiating first block\" ) self . add_block ( previous_hash = 1 , proof = 100 ) def add_block ( self , previous_hash : Optional [ str ] = None , proof : int = None ) -> Dict : \"\"\" Create a new block and add it to the chain. Args: previous_hash: string (optional), hash of the previous block in the chain. proof: integer, the proof given by the proof of work algorithm. Returns: The new block as a dictionary. \"\"\" logger . debug ( \"Creating a new block\" ) block = { \"index\" : len ( self . chain ) + 1 , \"timestamp\" : time (), \"transactions\" : self . current_transactions , \"proof\" : proof , \"previous_hash\" : previous_hash or self . hash ( self . chain [ -1 ] ), } logger . debug ( \"Resetting the current list of transations\" ) self . current_transactions = [] logger . debug ( \"Adding block to the chain\" ) self . chain . append ( block ) return block def add_transaction ( self , sender : str = None , recipient : str = None , amount : float = None ) -> int : \"\"\" Adds a new transaction to the list of transactions. Args: sender: string, address of the sender. recipient: string, address of the recipient. amount: float, the amount of the transaction. Returns: An integer containing the address of the block that will hold this transaction. \"\"\" logger . debug ( \"Adding transaction to the blockchain\" ) self . current_transactions . append ( { \"sender\" : sender , \"recipient\" : recipient , \"amount\" : amount } ) return self . last_block [ \"index\" ] + 1 @property def last_block ( self ) -> Dict : \"\"\" Returns the last block in the chain. Returns: The last block in the chain, as a dictionnary object. \"\"\" return self . chain [ -1 ] @staticmethod def hash ( block : Dict = None ) -> str : \"\"\" Hashes a new block. Args: block: dictionnary with the block's contents. Returns: The block's hash. \"\"\" logger . debug ( \"Ordering dictionary and dumping to json\" ) # ordering for consistent hashes block_string = json . dumps ( block , sort_keys = True ). encode () logger . debug ( \"Hashing dumped block\" ) return hashlib . sha256 ( block_string ). hexdigest () @staticmethod def validate_proof ( last_proof : int = None , new_proof : int = None ) -> bool : \"\"\" Validates a proof: does hash(last_proof, new_proof) contain 4 leading zeroes? Args: last_proof: integer, the previous proof in the chain. new_proof: integer, the new proof. Returns: True if new_proof is validated, False otherwise. \"\"\" logger . trace ( \"Checking proof validity\" ) guess = f \"{last_proof}{new_proof}\" . encode () guess_hash = hashlib . sha256 ( guess ). hexdigest () if guess_hash [ :4 ] == \"0000\" : logger . debug ( \"Proof iteration is valid\" ) return True else : logger . trace ( \"Proof is invalid\" ) return False def proof_of_work ( self , last_proof : int = None ) -> int : \"\"\" Simple Proof of Work Algorithm: - Find a number p' such that hash(pp') has leading 4 zeroes, where p is the previous p' - p is the previous proof, and p' is the new proof Args: last_proof: integer, the previous proof in the chain. Returns: The new proof, an integer. \"\"\" proof = 0 while self . validate_proof ( last_proof , proof ) is False : logger . trace ( \"Proof didn't pass, iterating\" ) proof += 1 logger . success ( \"Successfully mined block proof\" ) return proof def register_node ( self , address : str = None ) -> None : \"\"\" Register a new node as part of the network by adding it to the list of nodes. Args: address: string, address of node to register. Eg. 'http://192.168.0.5:5000' Returns: Nothing, adds in place. \"\"\" logger . debug ( f \"Parsing new node address {address}\" ) parsed_url : ParseResult = urlparse ( address ) node_netloc : str = parsed_url . netloc if node_netloc in self . nodes : logger . warning ( f \"Node at {address} is already registered, skipping\" ) logger . debug ( \"Adding new element to network's registered nodes\" ) self . nodes . add ( node_netloc ) def validate_chain ( self , chain : List [ Dict ] ) -> bool : \"\"\" Determine if a given blockchain from any arbitrary node in the network is valid. Args: chain: list, a complete blockchain (list of blocks as dicts). Returns: True if the chain is valid, False otherwise \"\"\" logger . debug ( \"Determining chain validity\" ) last_block = chain [ 0 ] for current_index in range ( 1 , len ( chain )) : logger . trace ( f \"Inspecting block at index {current_index}\" ) inspected_block = chain [ current_index ] logger . trace ( \"Checking block's hash\" ) if inspected_block [ \"previous_hash\" ] != self . hash ( last_block ) : logger . error ( f \"Invalid block tag 'previous_hash' \" f \"{inspected_block['previous_hash']}\" ) return False logger . trace ( \"Checking block's proof of work\" ) if not self . validate_proof ( last_proof = last_block [ \"proof\" ] , new_proof = inspected_block [ \"proof\" ] ) : logger . error ( f \"Invalid proof from last block's proof {last_block['proof']} and \" f \"inspected block's proof {inspected_block['proof']}\" ) return False logger . trace ( \"Moving on to next block\" ) last_block = inspected_block logger . debug ( \"Chain is valid!\" ) return True def resolve_conflicts ( self ) -> bool : \"\"\" This is the Consensus Algorithm. It resolves conflicts by replacing the node's chain with the longest valid one in the network. Returns: True if the node's chain was replaced, False otherwise \"\"\" neighbouring_nodes = self . nodes new_chain = None max_length = len ( self . chain ) # initialize with this node 's length logger.debug(\"Verifying chains from all nodes in the network\") for node in neighbouring_nodes: logger.debug(\"Querying node for its full chain\") node_chain_response = requests.get(f\"http://{node}/chain\") if node_chain_response.status_code == 200: logger.trace(\"Full chain received\") length = node_chain_response.json()[\"length\"] chain = node_chain_response.json()[\"chain\"] logger.trace(\"Checking if requested chain is valid and longer than mine\") if length > max_length and self.validate_chain(chain): max_length = length new_chain = chain if new_chain: logger.info(\"Found a valid chain longer than this node' s , adopting it now \") self.chain = new_chain return True logger.info(\" No valid chain was longer than this node ' s \" ) return False Static methods hash def hash ( block : Dict = None ) -> str Hashes a new block. Args: block: dictionnary with the block's contents. Returns: The block's hash. View Source @staticmethod def hash ( block : Dict = None ) -> str : \"\"\" Hashes a new block. Args: block: dictionnary with the block's contents. Returns: The block's hash. \"\"\" logger . debug ( \"Ordering dictionary and dumping to json\" ) # ordering for consistent hashes block_string = json . dumps ( block , sort_keys = True ). encode () logger . debug ( \"Hashing dumped block\" ) return hashlib . sha256 ( block_string ). hexdigest () validate_proof def validate_proof ( last_proof : int = None , new_proof : int = None ) -> bool Validates a proof: does hash(last_proof, new_proof) contain 4 leading zeroes? Args: last_proof: integer, the previous proof in the chain. new_proof: integer, the new proof. Returns: True if new_proof is validated, False otherwise. View Source @staticmethod def validate_proof ( last_proof : int = None , new_proof : int = None ) -> bool : \"\"\" Validates a proof: does hash(last_proof, new_proof) contain 4 leading zeroes? Args: last_proof: integer, the previous proof in the chain. new_proof: integer, the new proof. Returns: True if new_proof is validated, False otherwise. \"\"\" logger . trace ( \"Checking proof validity\" ) guess = f \"{last_proof}{new_proof}\" . encode () guess_hash = hashlib . sha256 ( guess ). hexdigest () if guess_hash [ :4 ] == \"0000\" : logger . debug ( \"Proof iteration is valid\" ) return True else : logger . trace ( \"Proof is invalid\" ) return False Instance variables last_block Returns the last block in the chain. Returns: The last block in the chain, as a dictionnary object. Methods add_block def add_block ( self , previous_hash : Union [ str , NoneType ] = None , proof : int = None ) -> Dict Create a new block and add it to the chain. Args: previous_hash: string (optional), hash of the previous block in the chain. proof: integer, the proof given by the proof of work algorithm. Returns: The new block as a dictionary. View Source def add_block ( self , previous_hash : Optional [ str ] = None , proof : int = None ) -> Dict : \"\"\" Create a new block and add it to the chain. Args: previous_hash: string (optional), hash of the previous block in the chain. proof: integer, the proof given by the proof of work algorithm. Returns: The new block as a dictionary. \"\"\" logger . debug ( \"Creating a new block\" ) block = { \"index\" : len ( self . chain ) + 1 , \"timestamp\" : time (), \"transactions\" : self . current_transactions , \"proof\" : proof , \"previous_hash\" : previous_hash or self . hash ( self . chain [ -1 ] ), } logger . debug ( \"Resetting the current list of transations\" ) self . current_transactions = [] logger . debug ( \"Adding block to the chain\" ) self . chain . append ( block ) return block add_transaction def add_transaction ( self , sender : str = None , recipient : str = None , amount : float = None ) -> int Adds a new transaction to the list of transactions. Args: sender: string, address of the sender. recipient: string, address of the recipient. amount: float, the amount of the transaction. Returns: An integer containing the address of the block that will hold this transaction. View Source def add_transaction ( self , sender : str = None , recipient : str = None , amount : float = None ) -> int : \"\"\" Adds a new transaction to the list of transactions. Args: sender: string, address of the sender. recipient: string, address of the recipient. amount: float, the amount of the transaction. Returns: An integer containing the address of the block that will hold this transaction. \"\"\" logger . debug ( \"Adding transaction to the blockchain\" ) self . current_transactions . append ( { \"sender\" : sender , \"recipient\" : recipient , \"amount\" : amount } ) return self . last_block [ \"index\" ] + 1 proof_of_work def proof_of_work ( self , last_proof : int = None ) -> int Simple Proof of Work Algorithm: - Find a number p' such that hash(pp') has leading 4 zeroes, where p is the previous p' - p is the previous proof, and p' is the new proof Args: last_proof: integer, the previous proof in the chain. Returns: The new proof, an integer. View Source def proof_of_work ( self , last_proof : int = None ) -> int : \"\"\" Simple Proof of Work Algorithm: - Find a number p' such that hash(pp') has leading 4 zeroes, where p is the previous p' - p is the previous proof, and p' is the new proof Args: last_proof: integer, the previous proof in the chain. Returns: The new proof, an integer. \"\"\" proof = 0 while self . validate_proof ( last_proof , proof ) is False : logger . trace ( \"Proof didn't pass, iterating\" ) proof += 1 logger . success ( \"Successfully mined block proof\" ) return proof register_node def register_node ( self , address : str = None ) -> None Register a new node as part of the network by adding it to the list of nodes. Args: address: string, address of node to register. Eg. ' http://192.168.0.5:5000 ' Returns: Nothing, adds in place. View Source def register_node ( self , address : str = None ) -> None : \"\"\" Register a new node as part of the network by adding it to the list of nodes. Args: address: string, address of node to register. Eg. 'http://192.168.0.5:5000' Returns: Nothing, adds in place. \"\"\" logger . debug ( f \"Parsing new node address {address}\" ) parsed_url : ParseResult = urlparse ( address ) node_netloc : str = parsed_url . netloc if node_netloc in self . nodes : logger . warning ( f \"Node at {address} is already registered, skipping\" ) logger . debug ( \"Adding new element to network's registered nodes\" ) self . nodes . add ( node_netloc ) resolve_conflicts def resolve_conflicts ( self ) -> bool This is the Consensus Algorithm. It resolves conflicts by replacing the node's chain with the longest valid one in the network. Returns: True if the node's chain was replaced, False otherwise View Source def resolve_conflicts ( self ) -> bool : \"\"\" This is the Consensus Algorithm. It resolves conflicts by replacing the node's chain with the longest valid one in the network. Returns: True if the node's chain was replaced, False otherwise \"\"\" neighbouring_nodes = self . nodes new_chain = None max_length = len ( self . chain ) # initialize with this node 's length logger.debug(\"Verifying chains from all nodes in the network\") for node in neighbouring_nodes: logger.debug(\"Querying node for its full chain\") node_chain_response = requests.get(f\"http://{node}/chain\") if node_chain_response.status_code == 200: logger.trace(\"Full chain received\") length = node_chain_response.json()[\"length\"] chain = node_chain_response.json()[\"chain\"] logger.trace(\"Checking if requested chain is valid and longer than mine\") if length > max_length and self.validate_chain(chain): max_length = length new_chain = chain if new_chain: logger.info(\"Found a valid chain longer than this node' s , adopting it now \") self.chain = new_chain return True logger.info(\" No valid chain was longer than this node ' s \" ) return False validate_chain def validate_chain ( self , chain : List [ Dict ] ) -> bool Determine if a given blockchain from any arbitrary node in the network is valid. Args: chain: list, a complete blockchain (list of blocks as dicts). Returns: True if the chain is valid, False otherwise View Source def validate_chain ( self , chain : List [ Dict ] ) -> bool : \"\"\" Determine if a given blockchain from any arbitrary node in the network is valid. Args: chain: list, a complete blockchain (list of blocks as dicts). Returns: True if the chain is valid, False otherwise \"\"\" logger . debug ( \"Determining chain validity\" ) last_block = chain [ 0 ] for current_index in range ( 1 , len ( chain )) : logger . trace ( f \"Inspecting block at index {current_index}\" ) inspected_block = chain [ current_index ] logger . trace ( \"Checking block's hash\" ) if inspected_block [ \"previous_hash\" ] != self . hash ( last_block ) : logger . error ( f \"Invalid block tag 'previous_hash' \" f \"{inspected_block['previous_hash']}\" ) return False logger . trace ( \"Checking block's proof of work\" ) if not self . validate_proof ( last_proof = last_block [ \"proof\" ] , new_proof = inspected_block [ \"proof\" ] ) : logger . error ( f \"Invalid proof from last block's proof {last_block['proof']} and \" f \"inspected block's proof {inspected_block['proof']}\" ) return False logger . trace ( \"Moving on to next block\" ) last_block = inspected_block logger . debug ( \"Chain is valid!\" ) return True","title":"Blockchain"},{"location":"reference/toychain/blockchain/#module-toychainblockchain","text":"Simple emulation of a blockchain. View Source \"\"\" Simple emulation of a blockchain. \"\"\" import hashlib import json from time import time from typing import Dict , List , Optional from urllib.parse import ParseResult , urlparse import requests from loguru import logger class BlockChain : \"\"\"Simple class to emulate a blockchain\"\"\" def __init__ ( self ): self . chain : List [ Dict ] = [] self . current_transactions : List [ Dict ] = [] self . nodes = set () logger . debug ( \"Initiating first block\" ) self . add_block ( previous_hash = 1 , proof = 100 ) def add_block ( self , previous_hash : Optional [ str ] = None , proof : int = None ) -> Dict : \"\"\" Create a new block and add it to the chain. Args: previous_hash: string (optional), hash of the previous block in the chain. proof: integer, the proof given by the proof of work algorithm. Returns: The new block as a dictionary. \"\"\" logger . debug ( \"Creating a new block\" ) block = { \"index\" : len ( self . chain ) + 1 , \"timestamp\" : time (), \"transactions\" : self . current_transactions , \"proof\" : proof , \"previous_hash\" : previous_hash or self . hash ( self . chain [ - 1 ]), } logger . debug ( \"Resetting the current list of transations\" ) self . current_transactions = [] logger . debug ( \"Adding block to the chain\" ) self . chain . append ( block ) return block def add_transaction ( self , sender : str = None , recipient : str = None , amount : float = None ) -> int : \"\"\" Adds a new transaction to the list of transactions. Args: sender: string, address of the sender. recipient: string, address of the recipient. amount: float, the amount of the transaction. Returns: An integer containing the address of the block that will hold this transaction. \"\"\" logger . debug ( \"Adding transaction to the blockchain\" ) self . current_transactions . append ( { \"sender\" : sender , \"recipient\" : recipient , \"amount\" : amount } ) return self . last_block [ \"index\" ] + 1 @property def last_block ( self ) -> Dict : \"\"\" Returns the last block in the chain. Returns: The last block in the chain, as a dictionnary object. \"\"\" return self . chain [ - 1 ] @staticmethod def hash ( block : Dict = None ) -> str : \"\"\" Hashes a new block. Args: block: dictionnary with the block's contents. Returns: The block's hash. \"\"\" logger . debug ( \"Ordering dictionary and dumping to json\" ) # ordering for consistent hashes block_string = json . dumps ( block , sort_keys = True ) . encode () logger . debug ( \"Hashing dumped block\" ) return hashlib . sha256 ( block_string ) . hexdigest () @staticmethod def validate_proof ( last_proof : int = None , new_proof : int = None ) -> bool : \"\"\" Validates a proof: does hash(last_proof, new_proof) contain 4 leading zeroes? Args: last_proof: integer, the previous proof in the chain. new_proof: integer, the new proof. Returns: True if new_proof is validated, False otherwise. \"\"\" logger . trace ( \"Checking proof validity\" ) guess = f \"{last_proof}{new_proof}\" . encode () guess_hash = hashlib . sha256 ( guess ) . hexdigest () if guess_hash [: 4 ] == \"0000\" : logger . debug ( \"Proof iteration is valid\" ) return True else : logger . trace ( \"Proof is invalid\" ) return False def proof_of_work ( self , last_proof : int = None ) -> int : \"\"\" Simple Proof of Work Algorithm: - Find a number p' such that hash(pp') has leading 4 zeroes, where p is the previous p' - p is the previous proof, and p' is the new proof Args: last_proof: integer, the previous proof in the chain. Returns: The new proof, an integer. \"\"\" proof = 0 while self . validate_proof ( last_proof , proof ) is False : logger . trace ( \"Proof didn't pass, iterating\" ) proof += 1 logger . success ( \"Successfully mined block proof\" ) return proof def register_node ( self , address : str = None ) -> None : \"\"\" Register a new node as part of the network by adding it to the list of nodes. Args: address: string, address of node to register. Eg. 'http://192.168.0.5:5000' Returns: Nothing, adds in place. \"\"\" logger . debug ( f \"Parsing new node address {address}\" ) parsed_url : ParseResult = urlparse ( address ) node_netloc : str = parsed_url . netloc if node_netloc in self . nodes : logger . warning ( f \"Node at {address} is already registered, skipping\" ) logger . debug ( \"Adding new element to network's registered nodes\" ) self . nodes . add ( node_netloc ) def validate_chain ( self , chain : List [ Dict ]) -> bool : \"\"\" Determine if a given blockchain from any arbitrary node in the network is valid. Args: chain: list, a complete blockchain (list of blocks as dicts). Returns: True if the chain is valid, False otherwise \"\"\" logger . debug ( \"Determining chain validity\" ) last_block = chain [ 0 ] for current_index in range ( 1 , len ( chain )): logger . trace ( f \"Inspecting block at index {current_index}\" ) inspected_block = chain [ current_index ] logger . trace ( \"Checking block's hash\" ) if inspected_block [ \"previous_hash\" ] != self . hash ( last_block ): logger . error ( f \"Invalid block tag 'previous_hash' \" f \"{inspected_block['previous_hash']}\" ) return False logger . trace ( \"Checking block's proof of work\" ) if not self . validate_proof ( last_proof = last_block [ \"proof\" ], new_proof = inspected_block [ \"proof\" ] ): logger . error ( f \"Invalid proof from last block's proof {last_block['proof']} and \" f \"inspected block's proof {inspected_block['proof']}\" ) return False logger . trace ( \"Moving on to next block\" ) last_block = inspected_block logger . debug ( \"Chain is valid!\" ) return True def resolve_conflicts ( self ) -> bool : \"\"\" This is the Consensus Algorithm. It resolves conflicts by replacing the node's chain with the longest valid one in the network. Returns: True if the node's chain was replaced, False otherwise \"\"\" neighbouring_nodes = self . nodes new_chain = None max_length = len ( self . chain ) # initialize with this node's length logger . debug ( \"Verifying chains from all nodes in the network\" ) for node in neighbouring_nodes : logger . debug ( \"Querying node for its full chain\" ) node_chain_response = requests . get ( f \"http://{node}/chain\" ) if node_chain_response . status_code == 200 : logger . trace ( \"Full chain received\" ) length = node_chain_response . json ()[ \"length\" ] chain = node_chain_response . json ()[ \"chain\" ] logger . trace ( \"Checking if requested chain is valid and longer than mine\" ) if length > max_length and self . validate_chain ( chain ): max_length = length new_chain = chain if new_chain : logger . info ( \"Found a valid chain longer than this node's, adopting it now\" ) self . chain = new_chain return True logger . info ( \"No valid chain was longer than this node's\" ) return False","title":"Module toychain.blockchain"},{"location":"reference/toychain/blockchain/#classes","text":"","title":"Classes"},{"location":"reference/toychain/blockchain/#blockchain","text":"class BlockChain ( ) Simple class to emulate a blockchain View Source class BlockChain : \"\"\"Simple class to emulate a blockchain\"\"\" def __init__ ( self ) : self . chain : List [ Dict ] = [] self . current_transactions : List [ Dict ] = [] self . nodes = set () logger . debug ( \"Initiating first block\" ) self . add_block ( previous_hash = 1 , proof = 100 ) def add_block ( self , previous_hash : Optional [ str ] = None , proof : int = None ) -> Dict : \"\"\" Create a new block and add it to the chain. Args: previous_hash: string (optional), hash of the previous block in the chain. proof: integer, the proof given by the proof of work algorithm. Returns: The new block as a dictionary. \"\"\" logger . debug ( \"Creating a new block\" ) block = { \"index\" : len ( self . chain ) + 1 , \"timestamp\" : time (), \"transactions\" : self . current_transactions , \"proof\" : proof , \"previous_hash\" : previous_hash or self . hash ( self . chain [ -1 ] ), } logger . debug ( \"Resetting the current list of transations\" ) self . current_transactions = [] logger . debug ( \"Adding block to the chain\" ) self . chain . append ( block ) return block def add_transaction ( self , sender : str = None , recipient : str = None , amount : float = None ) -> int : \"\"\" Adds a new transaction to the list of transactions. Args: sender: string, address of the sender. recipient: string, address of the recipient. amount: float, the amount of the transaction. Returns: An integer containing the address of the block that will hold this transaction. \"\"\" logger . debug ( \"Adding transaction to the blockchain\" ) self . current_transactions . append ( { \"sender\" : sender , \"recipient\" : recipient , \"amount\" : amount } ) return self . last_block [ \"index\" ] + 1 @property def last_block ( self ) -> Dict : \"\"\" Returns the last block in the chain. Returns: The last block in the chain, as a dictionnary object. \"\"\" return self . chain [ -1 ] @staticmethod def hash ( block : Dict = None ) -> str : \"\"\" Hashes a new block. Args: block: dictionnary with the block's contents. Returns: The block's hash. \"\"\" logger . debug ( \"Ordering dictionary and dumping to json\" ) # ordering for consistent hashes block_string = json . dumps ( block , sort_keys = True ). encode () logger . debug ( \"Hashing dumped block\" ) return hashlib . sha256 ( block_string ). hexdigest () @staticmethod def validate_proof ( last_proof : int = None , new_proof : int = None ) -> bool : \"\"\" Validates a proof: does hash(last_proof, new_proof) contain 4 leading zeroes? Args: last_proof: integer, the previous proof in the chain. new_proof: integer, the new proof. Returns: True if new_proof is validated, False otherwise. \"\"\" logger . trace ( \"Checking proof validity\" ) guess = f \"{last_proof}{new_proof}\" . encode () guess_hash = hashlib . sha256 ( guess ). hexdigest () if guess_hash [ :4 ] == \"0000\" : logger . debug ( \"Proof iteration is valid\" ) return True else : logger . trace ( \"Proof is invalid\" ) return False def proof_of_work ( self , last_proof : int = None ) -> int : \"\"\" Simple Proof of Work Algorithm: - Find a number p' such that hash(pp') has leading 4 zeroes, where p is the previous p' - p is the previous proof, and p' is the new proof Args: last_proof: integer, the previous proof in the chain. Returns: The new proof, an integer. \"\"\" proof = 0 while self . validate_proof ( last_proof , proof ) is False : logger . trace ( \"Proof didn't pass, iterating\" ) proof += 1 logger . success ( \"Successfully mined block proof\" ) return proof def register_node ( self , address : str = None ) -> None : \"\"\" Register a new node as part of the network by adding it to the list of nodes. Args: address: string, address of node to register. Eg. 'http://192.168.0.5:5000' Returns: Nothing, adds in place. \"\"\" logger . debug ( f \"Parsing new node address {address}\" ) parsed_url : ParseResult = urlparse ( address ) node_netloc : str = parsed_url . netloc if node_netloc in self . nodes : logger . warning ( f \"Node at {address} is already registered, skipping\" ) logger . debug ( \"Adding new element to network's registered nodes\" ) self . nodes . add ( node_netloc ) def validate_chain ( self , chain : List [ Dict ] ) -> bool : \"\"\" Determine if a given blockchain from any arbitrary node in the network is valid. Args: chain: list, a complete blockchain (list of blocks as dicts). Returns: True if the chain is valid, False otherwise \"\"\" logger . debug ( \"Determining chain validity\" ) last_block = chain [ 0 ] for current_index in range ( 1 , len ( chain )) : logger . trace ( f \"Inspecting block at index {current_index}\" ) inspected_block = chain [ current_index ] logger . trace ( \"Checking block's hash\" ) if inspected_block [ \"previous_hash\" ] != self . hash ( last_block ) : logger . error ( f \"Invalid block tag 'previous_hash' \" f \"{inspected_block['previous_hash']}\" ) return False logger . trace ( \"Checking block's proof of work\" ) if not self . validate_proof ( last_proof = last_block [ \"proof\" ] , new_proof = inspected_block [ \"proof\" ] ) : logger . error ( f \"Invalid proof from last block's proof {last_block['proof']} and \" f \"inspected block's proof {inspected_block['proof']}\" ) return False logger . trace ( \"Moving on to next block\" ) last_block = inspected_block logger . debug ( \"Chain is valid!\" ) return True def resolve_conflicts ( self ) -> bool : \"\"\" This is the Consensus Algorithm. It resolves conflicts by replacing the node's chain with the longest valid one in the network. Returns: True if the node's chain was replaced, False otherwise \"\"\" neighbouring_nodes = self . nodes new_chain = None max_length = len ( self . chain ) # initialize with this node 's length logger.debug(\"Verifying chains from all nodes in the network\") for node in neighbouring_nodes: logger.debug(\"Querying node for its full chain\") node_chain_response = requests.get(f\"http://{node}/chain\") if node_chain_response.status_code == 200: logger.trace(\"Full chain received\") length = node_chain_response.json()[\"length\"] chain = node_chain_response.json()[\"chain\"] logger.trace(\"Checking if requested chain is valid and longer than mine\") if length > max_length and self.validate_chain(chain): max_length = length new_chain = chain if new_chain: logger.info(\"Found a valid chain longer than this node' s , adopting it now \") self.chain = new_chain return True logger.info(\" No valid chain was longer than this node ' s \" ) return False","title":"BlockChain"},{"location":"reference/toychain/blockchain/#static-methods","text":"","title":"Static methods"},{"location":"reference/toychain/blockchain/#hash","text":"def hash ( block : Dict = None ) -> str Hashes a new block. Args: block: dictionnary with the block's contents. Returns: The block's hash. View Source @staticmethod def hash ( block : Dict = None ) -> str : \"\"\" Hashes a new block. Args: block: dictionnary with the block's contents. Returns: The block's hash. \"\"\" logger . debug ( \"Ordering dictionary and dumping to json\" ) # ordering for consistent hashes block_string = json . dumps ( block , sort_keys = True ). encode () logger . debug ( \"Hashing dumped block\" ) return hashlib . sha256 ( block_string ). hexdigest ()","title":"hash"},{"location":"reference/toychain/blockchain/#validate_proof","text":"def validate_proof ( last_proof : int = None , new_proof : int = None ) -> bool Validates a proof: does hash(last_proof, new_proof) contain 4 leading zeroes? Args: last_proof: integer, the previous proof in the chain. new_proof: integer, the new proof. Returns: True if new_proof is validated, False otherwise. View Source @staticmethod def validate_proof ( last_proof : int = None , new_proof : int = None ) -> bool : \"\"\" Validates a proof: does hash(last_proof, new_proof) contain 4 leading zeroes? Args: last_proof: integer, the previous proof in the chain. new_proof: integer, the new proof. Returns: True if new_proof is validated, False otherwise. \"\"\" logger . trace ( \"Checking proof validity\" ) guess = f \"{last_proof}{new_proof}\" . encode () guess_hash = hashlib . sha256 ( guess ). hexdigest () if guess_hash [ :4 ] == \"0000\" : logger . debug ( \"Proof iteration is valid\" ) return True else : logger . trace ( \"Proof is invalid\" ) return False","title":"validate_proof"},{"location":"reference/toychain/blockchain/#instance-variables","text":"last_block Returns the last block in the chain. Returns: The last block in the chain, as a dictionnary object.","title":"Instance variables"},{"location":"reference/toychain/blockchain/#methods","text":"","title":"Methods"},{"location":"reference/toychain/blockchain/#add_block","text":"def add_block ( self , previous_hash : Union [ str , NoneType ] = None , proof : int = None ) -> Dict Create a new block and add it to the chain. Args: previous_hash: string (optional), hash of the previous block in the chain. proof: integer, the proof given by the proof of work algorithm. Returns: The new block as a dictionary. View Source def add_block ( self , previous_hash : Optional [ str ] = None , proof : int = None ) -> Dict : \"\"\" Create a new block and add it to the chain. Args: previous_hash: string (optional), hash of the previous block in the chain. proof: integer, the proof given by the proof of work algorithm. Returns: The new block as a dictionary. \"\"\" logger . debug ( \"Creating a new block\" ) block = { \"index\" : len ( self . chain ) + 1 , \"timestamp\" : time (), \"transactions\" : self . current_transactions , \"proof\" : proof , \"previous_hash\" : previous_hash or self . hash ( self . chain [ -1 ] ), } logger . debug ( \"Resetting the current list of transations\" ) self . current_transactions = [] logger . debug ( \"Adding block to the chain\" ) self . chain . append ( block ) return block","title":"add_block"},{"location":"reference/toychain/blockchain/#add_transaction","text":"def add_transaction ( self , sender : str = None , recipient : str = None , amount : float = None ) -> int Adds a new transaction to the list of transactions. Args: sender: string, address of the sender. recipient: string, address of the recipient. amount: float, the amount of the transaction. Returns: An integer containing the address of the block that will hold this transaction. View Source def add_transaction ( self , sender : str = None , recipient : str = None , amount : float = None ) -> int : \"\"\" Adds a new transaction to the list of transactions. Args: sender: string, address of the sender. recipient: string, address of the recipient. amount: float, the amount of the transaction. Returns: An integer containing the address of the block that will hold this transaction. \"\"\" logger . debug ( \"Adding transaction to the blockchain\" ) self . current_transactions . append ( { \"sender\" : sender , \"recipient\" : recipient , \"amount\" : amount } ) return self . last_block [ \"index\" ] + 1","title":"add_transaction"},{"location":"reference/toychain/blockchain/#proof_of_work","text":"def proof_of_work ( self , last_proof : int = None ) -> int Simple Proof of Work Algorithm: - Find a number p' such that hash(pp') has leading 4 zeroes, where p is the previous p' - p is the previous proof, and p' is the new proof Args: last_proof: integer, the previous proof in the chain. Returns: The new proof, an integer. View Source def proof_of_work ( self , last_proof : int = None ) -> int : \"\"\" Simple Proof of Work Algorithm: - Find a number p' such that hash(pp') has leading 4 zeroes, where p is the previous p' - p is the previous proof, and p' is the new proof Args: last_proof: integer, the previous proof in the chain. Returns: The new proof, an integer. \"\"\" proof = 0 while self . validate_proof ( last_proof , proof ) is False : logger . trace ( \"Proof didn't pass, iterating\" ) proof += 1 logger . success ( \"Successfully mined block proof\" ) return proof","title":"proof_of_work"},{"location":"reference/toychain/blockchain/#register_node","text":"def register_node ( self , address : str = None ) -> None Register a new node as part of the network by adding it to the list of nodes. Args: address: string, address of node to register. Eg. ' http://192.168.0.5:5000 ' Returns: Nothing, adds in place. View Source def register_node ( self , address : str = None ) -> None : \"\"\" Register a new node as part of the network by adding it to the list of nodes. Args: address: string, address of node to register. Eg. 'http://192.168.0.5:5000' Returns: Nothing, adds in place. \"\"\" logger . debug ( f \"Parsing new node address {address}\" ) parsed_url : ParseResult = urlparse ( address ) node_netloc : str = parsed_url . netloc if node_netloc in self . nodes : logger . warning ( f \"Node at {address} is already registered, skipping\" ) logger . debug ( \"Adding new element to network's registered nodes\" ) self . nodes . add ( node_netloc )","title":"register_node"},{"location":"reference/toychain/blockchain/#resolve_conflicts","text":"def resolve_conflicts ( self ) -> bool This is the Consensus Algorithm. It resolves conflicts by replacing the node's chain with the longest valid one in the network. Returns: True if the node's chain was replaced, False otherwise View Source def resolve_conflicts ( self ) -> bool : \"\"\" This is the Consensus Algorithm. It resolves conflicts by replacing the node's chain with the longest valid one in the network. Returns: True if the node's chain was replaced, False otherwise \"\"\" neighbouring_nodes = self . nodes new_chain = None max_length = len ( self . chain ) # initialize with this node 's length logger.debug(\"Verifying chains from all nodes in the network\") for node in neighbouring_nodes: logger.debug(\"Querying node for its full chain\") node_chain_response = requests.get(f\"http://{node}/chain\") if node_chain_response.status_code == 200: logger.trace(\"Full chain received\") length = node_chain_response.json()[\"length\"] chain = node_chain_response.json()[\"chain\"] logger.trace(\"Checking if requested chain is valid and longer than mine\") if length > max_length and self.validate_chain(chain): max_length = length new_chain = chain if new_chain: logger.info(\"Found a valid chain longer than this node' s , adopting it now \") self.chain = new_chain return True logger.info(\" No valid chain was longer than this node ' s \" ) return False","title":"resolve_conflicts"},{"location":"reference/toychain/blockchain/#validate_chain","text":"def validate_chain ( self , chain : List [ Dict ] ) -> bool Determine if a given blockchain from any arbitrary node in the network is valid. Args: chain: list, a complete blockchain (list of blocks as dicts). Returns: True if the chain is valid, False otherwise View Source def validate_chain ( self , chain : List [ Dict ] ) -> bool : \"\"\" Determine if a given blockchain from any arbitrary node in the network is valid. Args: chain: list, a complete blockchain (list of blocks as dicts). Returns: True if the chain is valid, False otherwise \"\"\" logger . debug ( \"Determining chain validity\" ) last_block = chain [ 0 ] for current_index in range ( 1 , len ( chain )) : logger . trace ( f \"Inspecting block at index {current_index}\" ) inspected_block = chain [ current_index ] logger . trace ( \"Checking block's hash\" ) if inspected_block [ \"previous_hash\" ] != self . hash ( last_block ) : logger . error ( f \"Invalid block tag 'previous_hash' \" f \"{inspected_block['previous_hash']}\" ) return False logger . trace ( \"Checking block's proof of work\" ) if not self . validate_proof ( last_proof = last_block [ \"proof\" ] , new_proof = inspected_block [ \"proof\" ] ) : logger . error ( f \"Invalid proof from last block's proof {last_block['proof']} and \" f \"inspected block's proof {inspected_block['proof']}\" ) return False logger . trace ( \"Moving on to next block\" ) last_block = inspected_block logger . debug ( \"Chain is valid!\" ) return True","title":"validate_chain"},{"location":"reference/toychain/node/","text":"Module toychain.node Node runner for Blockchain, to interact with using HTTP requests. View Source \"\"\" Node runner for Blockchain, to interact with using HTTP requests. \"\"\" import argparse from typing import Dict , List from uuid import uuid4 import uvicorn from fastapi import FastAPI from loguru import logger from pydantic import BaseModel from toychain.blockchain import BlockChain logger . info ( \"Instantiating node\" ) node = FastAPI () logger . info ( \"Generating globally unique address for this node\" ) node_identifier = str ( uuid4 ()) . replace ( \"-\" , \"\" ) logger . info ( f \"This is node ID {node_identifier}\" ) logger . info ( \"Instantiating Blockchain for this node\" ) blockchain = BlockChain () logger . success ( \"Blockchain up and running!\" ) class ActiveNode ( BaseModel ): nodes : List [ str ] class Transaction ( BaseModel ): sender : str recipient : str amount : float @node.get ( \"/\" ) def root (): \"\"\" Greet the user and direct to the docs, that will detail the available endpoints. Returns: A simple text \"\"\" return { \"message\" : \"This is a running node. To get a documentation overview of the available \" \"endpoints and their functionality, head over to the '/docs' endpoint (Swagger\" \"UI style), or the '/redoc' endpoint (ReDoc style).\" } @node.get ( \"/mine\" ) def mine_block (): \"\"\" Mining endpoint. GETing `/mine` triggers the following actions:\\n - Calculating the Proof of Work.\\n - Rewarding the miner (this node) by adding a transaction granting 1 coin.\\n - Forging the new Block by adding it to the chain.\\n Returns: A JSON response. \"\"\" logger . info ( \"Received GET request to add a block, mining proof for a new block\" ) last_block : Dict = blockchain . last_block last_proof : int = last_block [ \"proof\" ] mined_proof : int = blockchain . proof_of_work ( last_proof ) # We must receive a reward for finding the proof. # The sender is \"0\" to signify that this node has mined a new coin. blockchain . add_transaction ( sender = \"0\" , recipient = node_identifier , amount = 1 , ) logger . info ( \"Forging new block and adding it to the chain\" ) previous_hash : str = blockchain . hash ( last_block ) block : Dict = blockchain . add_block ( previous_hash = previous_hash , proof = mined_proof ) return { \"message\" : \"New Block Forged\" , \"index\" : block [ \"index\" ], \"transactions\" : block [ \"transactions\" ], \"proof\" : block [ \"proof\" ], \"previous_hash\" : block [ \"previous_hash\" ], } @node.post ( \"/transactions/new\" ) def new_transaction ( posted_transaction : Transaction ): \"\"\" Receives transaction data from a POST request and add it to the node's blockchain. Returns: A JSON response. \"\"\" logger . info ( \"Received POST request for new transaction\" ) logger . info ( \"Creating new transaction from POSTed data\" ) transaction_index : int = blockchain . add_transaction ( sender = posted_transaction . sender , recipient = posted_transaction . recipient , amount = posted_transaction . amount , ) return { \"message\" : \"Transaction added to the list of current transactions at \" f \"index {transaction_index}\" } @node.post ( \"/nodes/register\" ) def register_nodes ( posted_transaction : ActiveNode ): \"\"\" Receives new nodes' location from a POST request and register those to this node's network. Returns: A JSON response. \"\"\" logger . info ( \"Received POST request for new nodes registration, getting payload\" ) for node in posted_transaction . nodes : logger . debug ( \"Registering new node to the network\" ) blockchain . register_node ( node ) return { \"message\" : f \"{len(posted_transaction.nodes)} new nodes have been successfully added\" , \"total_nodes\" : list ( blockchain . nodes ), } @node.get ( \"/nodes/resolve\" ) def consensus (): \"\"\" Run consensus algorithm to resolve conflicts, sends back status (local node's chain changed, or not). Returns: A JSON response. \"\"\" logger . info ( \"Received a GET request to resolve conflicts\" ) is_replaced = blockchain . resolve_conflicts () if is_replaced : response = { \"message\" : \"Our chain was replaced\" , \"new_chain\" : blockchain . chain } else : response = { \"message\" : \"Our chain is authoritative\" , \"chain\" : blockchain . chain } return response @node.get ( \"/chain\" ) def full_chain (): \"\"\" GETing `/chain` will returns the full blockchain. Returns: The node's full blockchain list, as a JSON response. \"\"\" logger . info ( \"Full chain requested, sending...\" ) return { \"chain\" : blockchain . chain , \"length\" : len ( blockchain . chain ), } def _parse_arguments (): \"\"\"Simply parse the port on which to run.\"\"\" parser = argparse . ArgumentParser () parser . add_argument ( \"-p\" , \"--port\" , dest = \"port\" , default = 5000 , type = int , help = \"The port on which to run a node. Defaults to 5000.\" , ) parser . add_argument ( \"--host\" , dest = \"host\" , default = \"127.0.0.1\" , type = str , help = \"The host on which to run the node. Defaults to '127.0.0.1', known as 'localhost'.\" , ) return parser . parse_args () def run_node (): \"\"\"Runs the node\"\"\" commandline_arguments = _parse_arguments () uvicorn . run ( node , host = commandline_arguments . host , port = commandline_arguments . port ) if __name__ == \"__main__\" : run_node () Variables blockchain node node_identifier Functions consensus def consensus ( ) Run consensus algorithm to resolve conflicts, sends back status (local node's chain changed, or not). Returns: A JSON response. View Source @node . get ( \"/nodes/resolve\" ) def consensus () : \"\"\" Run consensus algorithm to resolve conflicts, sends back status (local node's chain changed, or not). Returns: A JSON response. \"\"\" logger . info ( \"Received a GET request to resolve conflicts\" ) is_replaced = blockchain . resolve_conflicts () if is_replaced : response = { \"message\" : \"Our chain was replaced\" , \"new_chain\" : blockchain . chain } else : response = { \"message\" : \"Our chain is authoritative\" , \"chain\" : blockchain . chain } return response full_chain def full_chain ( ) GETing /chain will returns the full blockchain. Returns: The node's full blockchain list, as a JSON response. View Source @node . get ( \"/chain\" ) def full_chain () : \"\"\" GETing `/chain` will returns the full blockchain. Returns: The node's full blockchain list, as a JSON response. \"\"\" logger . info ( \"Full chain requested, sending...\" ) return { \"chain\" : blockchain . chain , \"length\" : len ( blockchain . chain ), } mine_block def mine_block ( ) Mining endpoint. GETing /mine triggers the following actions: - Calculating the Proof of Work . - Rewarding the miner ( this node ) by adding a transaction granting 1 coin . - Forging the new Block by adding it to the chain . Returns: A JSON response. View Source @node . get ( \"/mine\" ) def mine_block () : \"\"\" Mining endpoint. GETing `/mine` triggers the following actions:\\n - Calculating the Proof of Work.\\n - Rewarding the miner (this node) by adding a transaction granting 1 coin.\\n - Forging the new Block by adding it to the chain.\\n Returns: A JSON response. \"\"\" logger . info ( \"Received GET request to add a block, mining proof for a new block\" ) last_block : Dict = blockchain . last_block last_proof : int = last_block [ \"proof\" ] mined_proof : int = blockchain . proof_of_work ( last_proof ) # We must receive a reward for finding the proof . # The sender is \"0\" to signify that this node has mined a new coin . blockchain . add_transaction ( sender = \"0\" , recipient = node_identifier , amount = 1 , ) logger . info ( \"Forging new block and adding it to the chain\" ) previous_hash : str = blockchain . hash ( last_block ) block : Dict = blockchain . add_block ( previous_hash = previous_hash , proof = mined_proof ) return { \"message\" : \"New Block Forged\" , \"index\" : block [ \"index\" ] , \"transactions\" : block [ \"transactions\" ] , \"proof\" : block [ \"proof\" ] , \"previous_hash\" : block [ \"previous_hash\" ] , } new_transaction def new_transaction ( posted_transaction : toychain . node . Transaction ) Receives transaction data from a POST request and add it to the node's blockchain. Returns: A JSON response. View Source @node . post ( \"/transactions/new\" ) def new_transaction ( posted_transaction : Transaction ) : \"\"\" Receives transaction data from a POST request and add it to the node's blockchain. Returns: A JSON response. \"\"\" logger . info ( \"Received POST request for new transaction\" ) logger . info ( \"Creating new transaction from POSTed data\" ) transaction_index : int = blockchain . add_transaction ( sender = posted_transaction . sender , recipient = posted_transaction . recipient , amount = posted_transaction . amount , ) return { \"message\" : \"Transaction added to the list of current transactions at \" f \"index {transaction_index}\" } register_nodes def register_nodes ( posted_transaction : toychain . node . ActiveNode ) Receives new nodes' location from a POST request and register those to this node's network. Returns: A JSON response. View Source @node . post ( \"/nodes/register\" ) def register_nodes ( posted_transaction : ActiveNode ) : \"\"\" Receives new nodes' location from a POST request and register those to this node's network. Returns: A JSON response. \"\"\" logger . info ( \"Received POST request for new nodes registration, getting payload\" ) for node in posted_transaction . nodes : logger . debug ( \"Registering new node to the network\" ) blockchain . register_node ( node ) return { \"message\" : f \"{len(posted_transaction.nodes)} new nodes have been successfully added\" , \"total_nodes\" : list ( blockchain . nodes ), } root def root ( ) Greet the user and direct to the docs, that will detail the available endpoints. Returns: A simple text View Source @node . get ( \"/\" ) def root () : \"\"\" Greet the user and direct to the docs, that will detail the available endpoints. Returns: A simple text \"\"\" return { \"message\" : \"This is a running node. To get a documentation overview of the available \" \"endpoints and their functionality, head over to the '/docs' endpoint (Swagger\" \"UI style), or the '/redoc' endpoint (ReDoc style).\" } run_node def run_node ( ) Runs the node View Source def run_node (): \"\"\"Runs the node\"\"\" commandline_arguments = _parse_arguments () uvicorn . run ( node , host = commandline_arguments . host , port = commandline_arguments . port ) Classes ActiveNode class ActiveNode ( __pydantic_self__ , ** data : Any ) View Source class ActiveNode ( BaseModel ) : nodes : List [ str ] Ancestors (in MRO) pydantic.main.BaseModel pydantic.utils.Representation Class variables Config Static methods construct def construct ( _fields_set : Union [ ForwardRef ( 'SetStr' ), NoneType ] = None , ** values : Any ) -> 'Model' Creates a new model setting dict and fields_set from trusted or pre-validated data. Default values are respected, but no other validation is performed. from_orm def from_orm ( obj : Any ) -> 'Model' parse_file def parse_file ( path : Union [ str , pathlib . Path ], * , content_type : 'unicode' = None , encoding : 'unicode' = 'utf8' , proto : pydantic . parse . Protocol = None , allow_pickle : bool = False ) -> 'Model' parse_obj def parse_obj ( obj : Any ) -> 'Model' parse_raw def parse_raw ( b : Union [ str , bytes ], * , content_type : 'unicode' = None , encoding : 'unicode' = 'utf8' , proto : pydantic . parse . Protocol = None , allow_pickle : bool = False ) -> 'Model' schema def schema ( by_alias : bool = True ) -> 'DictStrAny' schema_json def schema_json ( * , by_alias : bool = True , ** dumps_kwargs : Any ) -> 'unicode' update_forward_refs def update_forward_refs ( ** localns : Any ) -> None Try to update ForwardRefs on fields based on this Model, globalns and localns. validate def validate ( value : Any ) -> 'Model' Instance variables fields Methods copy def copy ( self : 'Model' , * , include : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' )] = None , exclude : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' )] = None , update : 'DictStrAny' = None , deep : bool = False ) -> 'Model' Duplicate a model, optionally choose which fields to include, exclude and change. :param include: fields to include in new model :param exclude: fields to exclude from new model, as with values this takes precedence over include :param update: values to change/add in the new model. Note: the data is not validated before creating the new model: you should trust this data :param deep: set to True to make a deep copy of the model :return: new model instance dict def dict ( self , * , include : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' )] = None , exclude : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' )] = None , by_alias : bool = False , skip_defaults : bool = None , exclude_unset : bool = False , exclude_defaults : bool = False , exclude_none : bool = False ) -> 'DictStrAny' Generate a dictionary representation of the model, optionally specifying which fields to include or exclude. json def json ( self , * , include : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' )] = None , exclude : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' )] = None , by_alias : bool = False , skip_defaults : bool = None , exclude_unset : bool = False , exclude_defaults : bool = False , exclude_none : bool = False , encoder : Union [ Callable [[ Any ], Any ], NoneType ] = None , ** dumps_kwargs : Any ) -> 'unicode' Generate a JSON representation of the model, include and exclude arguments as per dict() . encoder is an optional function to supply as default to json.dumps(), other arguments as per json.dumps() . to_string def to_string ( self , pretty : bool = False ) -> 'unicode' Transaction class Transaction ( __pydantic_self__ , ** data : Any ) View Source class Transaction ( BaseModel ): sender: str recipient: str amount: float Ancestors (in MRO) pydantic.main.BaseModel pydantic.utils.Representation Class variables Config Static methods construct def construct ( _fields_set : Union [ ForwardRef ( 'SetStr' ), NoneType ] = None , ** values : Any ) -> 'Model' Creates a new model setting dict and fields_set from trusted or pre-validated data. Default values are respected, but no other validation is performed. from_orm def from_orm ( obj : Any ) -> 'Model' parse_file def parse_file ( path : Union [ str , pathlib . Path ], * , content_type : 'unicode' = None , encoding : 'unicode' = 'utf8' , proto : pydantic . parse . Protocol = None , allow_pickle : bool = False ) -> 'Model' parse_obj def parse_obj ( obj : Any ) -> 'Model' parse_raw def parse_raw ( b : Union [ str , bytes ], * , content_type : 'unicode' = None , encoding : 'unicode' = 'utf8' , proto : pydantic . parse . Protocol = None , allow_pickle : bool = False ) -> 'Model' schema def schema ( by_alias : bool = True ) -> 'DictStrAny' schema_json def schema_json ( * , by_alias : bool = True , ** dumps_kwargs : Any ) -> 'unicode' update_forward_refs def update_forward_refs ( ** localns : Any ) -> None Try to update ForwardRefs on fields based on this Model, globalns and localns. validate def validate ( value : Any ) -> 'Model' Instance variables fields Methods copy def copy ( self : 'Model' , * , include : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' )] = None , exclude : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' )] = None , update : 'DictStrAny' = None , deep : bool = False ) -> 'Model' Duplicate a model, optionally choose which fields to include, exclude and change. :param include: fields to include in new model :param exclude: fields to exclude from new model, as with values this takes precedence over include :param update: values to change/add in the new model. Note: the data is not validated before creating the new model: you should trust this data :param deep: set to True to make a deep copy of the model :return: new model instance dict def dict ( self , * , include : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' )] = None , exclude : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' )] = None , by_alias : bool = False , skip_defaults : bool = None , exclude_unset : bool = False , exclude_defaults : bool = False , exclude_none : bool = False ) -> 'DictStrAny' Generate a dictionary representation of the model, optionally specifying which fields to include or exclude. json def json ( self , * , include : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' )] = None , exclude : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' )] = None , by_alias : bool = False , skip_defaults : bool = None , exclude_unset : bool = False , exclude_defaults : bool = False , exclude_none : bool = False , encoder : Union [ Callable [[ Any ], Any ], NoneType ] = None , ** dumps_kwargs : Any ) -> 'unicode' Generate a JSON representation of the model, include and exclude arguments as per dict() . encoder is an optional function to supply as default to json.dumps(), other arguments as per json.dumps() . to_string def to_string ( self , pretty : bool = False ) -> 'unicode'","title":"Node"},{"location":"reference/toychain/node/#module-toychainnode","text":"Node runner for Blockchain, to interact with using HTTP requests. View Source \"\"\" Node runner for Blockchain, to interact with using HTTP requests. \"\"\" import argparse from typing import Dict , List from uuid import uuid4 import uvicorn from fastapi import FastAPI from loguru import logger from pydantic import BaseModel from toychain.blockchain import BlockChain logger . info ( \"Instantiating node\" ) node = FastAPI () logger . info ( \"Generating globally unique address for this node\" ) node_identifier = str ( uuid4 ()) . replace ( \"-\" , \"\" ) logger . info ( f \"This is node ID {node_identifier}\" ) logger . info ( \"Instantiating Blockchain for this node\" ) blockchain = BlockChain () logger . success ( \"Blockchain up and running!\" ) class ActiveNode ( BaseModel ): nodes : List [ str ] class Transaction ( BaseModel ): sender : str recipient : str amount : float @node.get ( \"/\" ) def root (): \"\"\" Greet the user and direct to the docs, that will detail the available endpoints. Returns: A simple text \"\"\" return { \"message\" : \"This is a running node. To get a documentation overview of the available \" \"endpoints and their functionality, head over to the '/docs' endpoint (Swagger\" \"UI style), or the '/redoc' endpoint (ReDoc style).\" } @node.get ( \"/mine\" ) def mine_block (): \"\"\" Mining endpoint. GETing `/mine` triggers the following actions:\\n - Calculating the Proof of Work.\\n - Rewarding the miner (this node) by adding a transaction granting 1 coin.\\n - Forging the new Block by adding it to the chain.\\n Returns: A JSON response. \"\"\" logger . info ( \"Received GET request to add a block, mining proof for a new block\" ) last_block : Dict = blockchain . last_block last_proof : int = last_block [ \"proof\" ] mined_proof : int = blockchain . proof_of_work ( last_proof ) # We must receive a reward for finding the proof. # The sender is \"0\" to signify that this node has mined a new coin. blockchain . add_transaction ( sender = \"0\" , recipient = node_identifier , amount = 1 , ) logger . info ( \"Forging new block and adding it to the chain\" ) previous_hash : str = blockchain . hash ( last_block ) block : Dict = blockchain . add_block ( previous_hash = previous_hash , proof = mined_proof ) return { \"message\" : \"New Block Forged\" , \"index\" : block [ \"index\" ], \"transactions\" : block [ \"transactions\" ], \"proof\" : block [ \"proof\" ], \"previous_hash\" : block [ \"previous_hash\" ], } @node.post ( \"/transactions/new\" ) def new_transaction ( posted_transaction : Transaction ): \"\"\" Receives transaction data from a POST request and add it to the node's blockchain. Returns: A JSON response. \"\"\" logger . info ( \"Received POST request for new transaction\" ) logger . info ( \"Creating new transaction from POSTed data\" ) transaction_index : int = blockchain . add_transaction ( sender = posted_transaction . sender , recipient = posted_transaction . recipient , amount = posted_transaction . amount , ) return { \"message\" : \"Transaction added to the list of current transactions at \" f \"index {transaction_index}\" } @node.post ( \"/nodes/register\" ) def register_nodes ( posted_transaction : ActiveNode ): \"\"\" Receives new nodes' location from a POST request and register those to this node's network. Returns: A JSON response. \"\"\" logger . info ( \"Received POST request for new nodes registration, getting payload\" ) for node in posted_transaction . nodes : logger . debug ( \"Registering new node to the network\" ) blockchain . register_node ( node ) return { \"message\" : f \"{len(posted_transaction.nodes)} new nodes have been successfully added\" , \"total_nodes\" : list ( blockchain . nodes ), } @node.get ( \"/nodes/resolve\" ) def consensus (): \"\"\" Run consensus algorithm to resolve conflicts, sends back status (local node's chain changed, or not). Returns: A JSON response. \"\"\" logger . info ( \"Received a GET request to resolve conflicts\" ) is_replaced = blockchain . resolve_conflicts () if is_replaced : response = { \"message\" : \"Our chain was replaced\" , \"new_chain\" : blockchain . chain } else : response = { \"message\" : \"Our chain is authoritative\" , \"chain\" : blockchain . chain } return response @node.get ( \"/chain\" ) def full_chain (): \"\"\" GETing `/chain` will returns the full blockchain. Returns: The node's full blockchain list, as a JSON response. \"\"\" logger . info ( \"Full chain requested, sending...\" ) return { \"chain\" : blockchain . chain , \"length\" : len ( blockchain . chain ), } def _parse_arguments (): \"\"\"Simply parse the port on which to run.\"\"\" parser = argparse . ArgumentParser () parser . add_argument ( \"-p\" , \"--port\" , dest = \"port\" , default = 5000 , type = int , help = \"The port on which to run a node. Defaults to 5000.\" , ) parser . add_argument ( \"--host\" , dest = \"host\" , default = \"127.0.0.1\" , type = str , help = \"The host on which to run the node. Defaults to '127.0.0.1', known as 'localhost'.\" , ) return parser . parse_args () def run_node (): \"\"\"Runs the node\"\"\" commandline_arguments = _parse_arguments () uvicorn . run ( node , host = commandline_arguments . host , port = commandline_arguments . port ) if __name__ == \"__main__\" : run_node ()","title":"Module toychain.node"},{"location":"reference/toychain/node/#variables","text":"blockchain node node_identifier","title":"Variables"},{"location":"reference/toychain/node/#functions","text":"","title":"Functions"},{"location":"reference/toychain/node/#consensus","text":"def consensus ( ) Run consensus algorithm to resolve conflicts, sends back status (local node's chain changed, or not). Returns: A JSON response. View Source @node . get ( \"/nodes/resolve\" ) def consensus () : \"\"\" Run consensus algorithm to resolve conflicts, sends back status (local node's chain changed, or not). Returns: A JSON response. \"\"\" logger . info ( \"Received a GET request to resolve conflicts\" ) is_replaced = blockchain . resolve_conflicts () if is_replaced : response = { \"message\" : \"Our chain was replaced\" , \"new_chain\" : blockchain . chain } else : response = { \"message\" : \"Our chain is authoritative\" , \"chain\" : blockchain . chain } return response","title":"consensus"},{"location":"reference/toychain/node/#full_chain","text":"def full_chain ( ) GETing /chain will returns the full blockchain. Returns: The node's full blockchain list, as a JSON response. View Source @node . get ( \"/chain\" ) def full_chain () : \"\"\" GETing `/chain` will returns the full blockchain. Returns: The node's full blockchain list, as a JSON response. \"\"\" logger . info ( \"Full chain requested, sending...\" ) return { \"chain\" : blockchain . chain , \"length\" : len ( blockchain . chain ), }","title":"full_chain"},{"location":"reference/toychain/node/#mine_block","text":"def mine_block ( ) Mining endpoint. GETing /mine triggers the following actions: - Calculating the Proof of Work . - Rewarding the miner ( this node ) by adding a transaction granting 1 coin . - Forging the new Block by adding it to the chain . Returns: A JSON response. View Source @node . get ( \"/mine\" ) def mine_block () : \"\"\" Mining endpoint. GETing `/mine` triggers the following actions:\\n - Calculating the Proof of Work.\\n - Rewarding the miner (this node) by adding a transaction granting 1 coin.\\n - Forging the new Block by adding it to the chain.\\n Returns: A JSON response. \"\"\" logger . info ( \"Received GET request to add a block, mining proof for a new block\" ) last_block : Dict = blockchain . last_block last_proof : int = last_block [ \"proof\" ] mined_proof : int = blockchain . proof_of_work ( last_proof ) # We must receive a reward for finding the proof . # The sender is \"0\" to signify that this node has mined a new coin . blockchain . add_transaction ( sender = \"0\" , recipient = node_identifier , amount = 1 , ) logger . info ( \"Forging new block and adding it to the chain\" ) previous_hash : str = blockchain . hash ( last_block ) block : Dict = blockchain . add_block ( previous_hash = previous_hash , proof = mined_proof ) return { \"message\" : \"New Block Forged\" , \"index\" : block [ \"index\" ] , \"transactions\" : block [ \"transactions\" ] , \"proof\" : block [ \"proof\" ] , \"previous_hash\" : block [ \"previous_hash\" ] , }","title":"mine_block"},{"location":"reference/toychain/node/#new_transaction","text":"def new_transaction ( posted_transaction : toychain . node . Transaction ) Receives transaction data from a POST request and add it to the node's blockchain. Returns: A JSON response. View Source @node . post ( \"/transactions/new\" ) def new_transaction ( posted_transaction : Transaction ) : \"\"\" Receives transaction data from a POST request and add it to the node's blockchain. Returns: A JSON response. \"\"\" logger . info ( \"Received POST request for new transaction\" ) logger . info ( \"Creating new transaction from POSTed data\" ) transaction_index : int = blockchain . add_transaction ( sender = posted_transaction . sender , recipient = posted_transaction . recipient , amount = posted_transaction . amount , ) return { \"message\" : \"Transaction added to the list of current transactions at \" f \"index {transaction_index}\" }","title":"new_transaction"},{"location":"reference/toychain/node/#register_nodes","text":"def register_nodes ( posted_transaction : toychain . node . ActiveNode ) Receives new nodes' location from a POST request and register those to this node's network. Returns: A JSON response. View Source @node . post ( \"/nodes/register\" ) def register_nodes ( posted_transaction : ActiveNode ) : \"\"\" Receives new nodes' location from a POST request and register those to this node's network. Returns: A JSON response. \"\"\" logger . info ( \"Received POST request for new nodes registration, getting payload\" ) for node in posted_transaction . nodes : logger . debug ( \"Registering new node to the network\" ) blockchain . register_node ( node ) return { \"message\" : f \"{len(posted_transaction.nodes)} new nodes have been successfully added\" , \"total_nodes\" : list ( blockchain . nodes ), }","title":"register_nodes"},{"location":"reference/toychain/node/#root","text":"def root ( ) Greet the user and direct to the docs, that will detail the available endpoints. Returns: A simple text View Source @node . get ( \"/\" ) def root () : \"\"\" Greet the user and direct to the docs, that will detail the available endpoints. Returns: A simple text \"\"\" return { \"message\" : \"This is a running node. To get a documentation overview of the available \" \"endpoints and their functionality, head over to the '/docs' endpoint (Swagger\" \"UI style), or the '/redoc' endpoint (ReDoc style).\" }","title":"root"},{"location":"reference/toychain/node/#run_node","text":"def run_node ( ) Runs the node View Source def run_node (): \"\"\"Runs the node\"\"\" commandline_arguments = _parse_arguments () uvicorn . run ( node , host = commandline_arguments . host , port = commandline_arguments . port )","title":"run_node"},{"location":"reference/toychain/node/#classes","text":"","title":"Classes"},{"location":"reference/toychain/node/#activenode","text":"class ActiveNode ( __pydantic_self__ , ** data : Any ) View Source class ActiveNode ( BaseModel ) : nodes : List [ str ]","title":"ActiveNode"},{"location":"reference/toychain/node/#ancestors-in-mro","text":"pydantic.main.BaseModel pydantic.utils.Representation","title":"Ancestors (in MRO)"},{"location":"reference/toychain/node/#class-variables","text":"Config","title":"Class variables"},{"location":"reference/toychain/node/#static-methods","text":"","title":"Static methods"},{"location":"reference/toychain/node/#construct","text":"def construct ( _fields_set : Union [ ForwardRef ( 'SetStr' ), NoneType ] = None , ** values : Any ) -> 'Model' Creates a new model setting dict and fields_set from trusted or pre-validated data. Default values are respected, but no other validation is performed.","title":"construct"},{"location":"reference/toychain/node/#from_orm","text":"def from_orm ( obj : Any ) -> 'Model'","title":"from_orm"},{"location":"reference/toychain/node/#parse_file","text":"def parse_file ( path : Union [ str , pathlib . Path ], * , content_type : 'unicode' = None , encoding : 'unicode' = 'utf8' , proto : pydantic . parse . Protocol = None , allow_pickle : bool = False ) -> 'Model'","title":"parse_file"},{"location":"reference/toychain/node/#parse_obj","text":"def parse_obj ( obj : Any ) -> 'Model'","title":"parse_obj"},{"location":"reference/toychain/node/#parse_raw","text":"def parse_raw ( b : Union [ str , bytes ], * , content_type : 'unicode' = None , encoding : 'unicode' = 'utf8' , proto : pydantic . parse . Protocol = None , allow_pickle : bool = False ) -> 'Model'","title":"parse_raw"},{"location":"reference/toychain/node/#schema","text":"def schema ( by_alias : bool = True ) -> 'DictStrAny'","title":"schema"},{"location":"reference/toychain/node/#schema_json","text":"def schema_json ( * , by_alias : bool = True , ** dumps_kwargs : Any ) -> 'unicode'","title":"schema_json"},{"location":"reference/toychain/node/#update_forward_refs","text":"def update_forward_refs ( ** localns : Any ) -> None Try to update ForwardRefs on fields based on this Model, globalns and localns.","title":"update_forward_refs"},{"location":"reference/toychain/node/#validate","text":"def validate ( value : Any ) -> 'Model'","title":"validate"},{"location":"reference/toychain/node/#instance-variables","text":"fields","title":"Instance variables"},{"location":"reference/toychain/node/#methods","text":"","title":"Methods"},{"location":"reference/toychain/node/#copy","text":"def copy ( self : 'Model' , * , include : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' )] = None , exclude : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' )] = None , update : 'DictStrAny' = None , deep : bool = False ) -> 'Model' Duplicate a model, optionally choose which fields to include, exclude and change. :param include: fields to include in new model :param exclude: fields to exclude from new model, as with values this takes precedence over include :param update: values to change/add in the new model. Note: the data is not validated before creating the new model: you should trust this data :param deep: set to True to make a deep copy of the model :return: new model instance","title":"copy"},{"location":"reference/toychain/node/#dict","text":"def dict ( self , * , include : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' )] = None , exclude : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' )] = None , by_alias : bool = False , skip_defaults : bool = None , exclude_unset : bool = False , exclude_defaults : bool = False , exclude_none : bool = False ) -> 'DictStrAny' Generate a dictionary representation of the model, optionally specifying which fields to include or exclude.","title":"dict"},{"location":"reference/toychain/node/#json","text":"def json ( self , * , include : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' )] = None , exclude : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' )] = None , by_alias : bool = False , skip_defaults : bool = None , exclude_unset : bool = False , exclude_defaults : bool = False , exclude_none : bool = False , encoder : Union [ Callable [[ Any ], Any ], NoneType ] = None , ** dumps_kwargs : Any ) -> 'unicode' Generate a JSON representation of the model, include and exclude arguments as per dict() . encoder is an optional function to supply as default to json.dumps(), other arguments as per json.dumps() .","title":"json"},{"location":"reference/toychain/node/#to_string","text":"def to_string ( self , pretty : bool = False ) -> 'unicode'","title":"to_string"},{"location":"reference/toychain/node/#transaction","text":"class Transaction ( __pydantic_self__ , ** data : Any ) View Source class Transaction ( BaseModel ): sender: str recipient: str amount: float","title":"Transaction"},{"location":"reference/toychain/node/#ancestors-in-mro_1","text":"pydantic.main.BaseModel pydantic.utils.Representation","title":"Ancestors (in MRO)"},{"location":"reference/toychain/node/#class-variables_1","text":"Config","title":"Class variables"},{"location":"reference/toychain/node/#static-methods_1","text":"","title":"Static methods"},{"location":"reference/toychain/node/#construct_1","text":"def construct ( _fields_set : Union [ ForwardRef ( 'SetStr' ), NoneType ] = None , ** values : Any ) -> 'Model' Creates a new model setting dict and fields_set from trusted or pre-validated data. Default values are respected, but no other validation is performed.","title":"construct"},{"location":"reference/toychain/node/#from_orm_1","text":"def from_orm ( obj : Any ) -> 'Model'","title":"from_orm"},{"location":"reference/toychain/node/#parse_file_1","text":"def parse_file ( path : Union [ str , pathlib . Path ], * , content_type : 'unicode' = None , encoding : 'unicode' = 'utf8' , proto : pydantic . parse . Protocol = None , allow_pickle : bool = False ) -> 'Model'","title":"parse_file"},{"location":"reference/toychain/node/#parse_obj_1","text":"def parse_obj ( obj : Any ) -> 'Model'","title":"parse_obj"},{"location":"reference/toychain/node/#parse_raw_1","text":"def parse_raw ( b : Union [ str , bytes ], * , content_type : 'unicode' = None , encoding : 'unicode' = 'utf8' , proto : pydantic . parse . Protocol = None , allow_pickle : bool = False ) -> 'Model'","title":"parse_raw"},{"location":"reference/toychain/node/#schema_1","text":"def schema ( by_alias : bool = True ) -> 'DictStrAny'","title":"schema"},{"location":"reference/toychain/node/#schema_json_1","text":"def schema_json ( * , by_alias : bool = True , ** dumps_kwargs : Any ) -> 'unicode'","title":"schema_json"},{"location":"reference/toychain/node/#update_forward_refs_1","text":"def update_forward_refs ( ** localns : Any ) -> None Try to update ForwardRefs on fields based on this Model, globalns and localns.","title":"update_forward_refs"},{"location":"reference/toychain/node/#validate_1","text":"def validate ( value : Any ) -> 'Model'","title":"validate"},{"location":"reference/toychain/node/#instance-variables_1","text":"fields","title":"Instance variables"},{"location":"reference/toychain/node/#methods_1","text":"","title":"Methods"},{"location":"reference/toychain/node/#copy_1","text":"def copy ( self : 'Model' , * , include : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' )] = None , exclude : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' )] = None , update : 'DictStrAny' = None , deep : bool = False ) -> 'Model' Duplicate a model, optionally choose which fields to include, exclude and change. :param include: fields to include in new model :param exclude: fields to exclude from new model, as with values this takes precedence over include :param update: values to change/add in the new model. Note: the data is not validated before creating the new model: you should trust this data :param deep: set to True to make a deep copy of the model :return: new model instance","title":"copy"},{"location":"reference/toychain/node/#dict_1","text":"def dict ( self , * , include : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' )] = None , exclude : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' )] = None , by_alias : bool = False , skip_defaults : bool = None , exclude_unset : bool = False , exclude_defaults : bool = False , exclude_none : bool = False ) -> 'DictStrAny' Generate a dictionary representation of the model, optionally specifying which fields to include or exclude.","title":"dict"},{"location":"reference/toychain/node/#json_1","text":"def json ( self , * , include : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' )] = None , exclude : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' )] = None , by_alias : bool = False , skip_defaults : bool = None , exclude_unset : bool = False , exclude_defaults : bool = False , exclude_none : bool = False , encoder : Union [ Callable [[ Any ], Any ], NoneType ] = None , ** dumps_kwargs : Any ) -> 'unicode' Generate a JSON representation of the model, include and exclude arguments as per dict() . encoder is an optional function to supply as default to json.dumps(), other arguments as per json.dumps() .","title":"json"},{"location":"reference/toychain/node/#to_string_1","text":"def to_string ( self , pretty : bool = False ) -> 'unicode'","title":"to_string"}]}